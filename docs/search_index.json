[["index.html", "Introduction to R Course to Learn the Basics of R Presentation of the Book", " Introduction to R Course to Learn the Basics of R by Claudio Zandonella Callegher and Filippo Gambarota (revision and translation into English by Enrico Toffalini), members of Psicostat 31-10-2024 Presentation of the Book In this book we will learn the basics of R, one of the best programming language and software for statistical analysis and data visualization. We will start from scratch by understanding the fundamental aspects of R and the concepts behind each programming language that will allow you to later deepen and develop your skills in this beautiful world. Related GitHub repository at https://github.com/psicostat/Introduction2R_EN Original Italian version at https://psicostat.github.io/Introduction2R/ Why R There are many reasons to choose R over other programs used for conducting statistical analyses. First of all, it is a programming language (like Python, Java, C++, or Julia) and not simply a point-and-click interface (such as SPSS or JASP). This initially presents more challenges, but it will reward you in the future because you will have learned to use a very powerful tool. Additionally, R is: designed for statistics free and open-source rich in packages supported by a large community still growing Contents The book is currently divided into four main sections: Getting Started. Once R and RStudio are installed, we will familiarize with the work environment introducing some general aspects and main functions. We will also describe some good rules for starting a working session in R. Data Structures (vectors, factors, matrices, dataframes, lists). We will learn the main objects used in R. The most common data structures will no longer have secrets and we will understand how to manipulate and use them according to the various needs. Algorithms (e.g., functions, if…else, loops). Don’t panic. You may have often heard of this as something very complicated, but in reality, algorithms are just a series of instructions that the computer follows when it has to perform a certain task. In this section we will see the main R commands used to define algorithms. After all, writing algorithms is the real advantage of knowing a programming language! Advanced Topics. This section is currently under development. At present, it includes only a single chapter on managing and manipulating strings. Additional chapters will be added in the future. At the end of this book you will probably not be hired by Google, but we hope at least that R does not scare you so much anymore and that maybe someone is interested in learning more about this fantastic world made of lines of code. Resources We point out here some further online material for the interested reader to deepen their knowledge of using R. Introductory material: R for Psychological Science by Danielle Navarro https://psyr.djnavarro.net/index.html Hands-On Programming with R by Garrett Grolemund https://rstudio-education.github.io/hopr/ Intermediate material: R for Data Science by Hadley Wickham and Garrett Grolemund https://r4ds.had.co.nz/ Advanced material: R Packages di Hadley Wickham e Jennifer Bryan https://r-pkgs.org/ Advanced R di Hadley Wickham https://adv-r.hadley.nz/ Psicostat This book was produced by Claudio Zandonella Callegher and Filippo Gambarota, and subsequently revised and translated into English by Enrico Toffalini, members of Psicostat, an interdisciplinary research group interested in Psychology and Statistics, our goal is to promote the connection between the two fields! If you want to know more about our activities visit our website https://psicostat.dpss.psy.unipd.it/ or add yourself to our mailing list https://lists.dpss.psy.unipd.it/postorius/lists/psicostat.lists.dpss.psy.unipd.it/. Contribute If you want to collaborate on the revision and writing of this book (of course, everything is in R), visit our GitHub repository: https://github.com/psicostat/Introduction2R. Acknowledgements The template of this book is based on Rstudio Bookdown-demo released under CC0-1.0 license and rstudio4edu-book released under CC BY license. Note that the illustrations used belong to rstudio4edu-book and are under CC BY-NC licensed. License This book is released under the Creative Commons Attribution-ShareAlike 4.0 International Public License (CC BY-SA). The illustrations used belong to rstudio4edu-book and are licensed under CC BY-NC. "],["section-1---getting-started.html", "Section 1 - Getting Started", " Section 1 - Getting Started In this section, we will first present the instructions for installing R and RStudio. Then, we will perform the first operations in R and familiarize ourselves with basic programming concepts such as objects and functions. Finally, we will introduce other concepts related to working sessions in R and describe some best practices for using R. The chapters are organized as follows: Chapter 1 - Installing R and RStudio. Step-by-step instructions for installing R and RStudio. Chapter 2 - RStudio Interface. Introduction to the RStudio user interface. Chapter 3 - First Steps in R. Mathematical operators, relational operators, logical operators. Chapter 4 - Two Inseparable Companions. Introduction to the concepts of objects and functions in R. Chapter 5 - Working Environment. Introduction to the concepts of Environment, working directory, and R packages. Chapter 6 - Working Session. Description of best practices in working sessions and error handling. "],["install.html", "Chapter1 Installing R e RStudio 1.1 Installing R 1.2 Installing R Studio", " Chapter1 Installing R e RStudio R and RStudio are two distinct pieces of software. R is a programming language, primarily used in fields such as statistics. RStudio, on the other hand, is a user-friendly interface and an Integrated Development Environment (IDE) specifically designed for R programming language (i.e., to facilitate the use of R). While R can be used on its own (i.e., with a Console alone), it is generally recommended to work with it through RStudio. Both need to be installed separately, and the installation process varies depending on the operating system (Windows, macOS, or Linux). We provide instructions only for Windows, macOS, and Linux (Ubuntu). Of course, R is available for all major Linux distributions. The instructions provided for Ubuntu (the most popular distribution) are also applicable to its derivative distributions. 1.1 Installing R Go to the website: https://www.r-project.org Select CRAN (Comprehensive R Archive Network) from the left-hand menu under Download Select the first link: https://cloud.r-project.org/ Select your operating system 1.1.1 R Windows Select base Select Download for the latest available version of R Once the download is complete, run the file and follow the instructions until the installation is finished 1.1.2 R MacOS Select the latest available version of R Once the download is complete, run the file and follow the instructions to complete the installation of R Next, you will also need to install an additional component XQuartz by clicking the link within the orange box shown in the previous figure Select Download Once the download is complete, run the file and follow the instructions to finish the installation 1.1.3 R Linux Despite the ease of installing packages on Linux, R can sometimes be more complicated to install due to the variety of distributions, repositories, and keys required to recognize the repository as secure. On CRAN there is an official guide with all the apt commands to run from the terminal. By following these steps, there should be no issues. Go to CRAN Click Download R for Linux Select your distribution (Ubuntu in this case) Follow the instructions, mainly running the suggested terminal commands For any difficulties or errors, especially in the Linux environment, an online search usually resolves the issue. Advanced uses of R require the installation of additional software known as R tools. Windows Select Rtools and follow the instructions to complete the installation. Note that some configuration steps are also required to ensure everything works correctly. MacOS Select tools and follow the provided instructions. Note in particular that with R 4.0, the following instructions are provided. 1.2 Installing R Studio Go to the website: https://rstudio.com Select DOWNLOAD IT NOW Select the free version of RStudio Desktop Select the correct version depending on your operating system Once the download is complete, run the file and follow the instructions to finish the installation 1.2.1 R Studio on Linux In this case, as with Windows and macOS, the installation consists of downloading and running the correct file, depending on the distribution (for example, .deb for Ubuntu and derivatives). Importantly, in the case of Ubuntu (but this should apply to other distributions as well), even versions later than the one indicated (e.g., Ubuntu 16) are fully compatible. "],["rstudio-gui.html", "Chapter2 RStudio Interface", " Chapter2 RStudio Interface In this chapter, we will introduce the RStudio user interface. Many aspects briefly introduced here will be discussed in subsequent chapters. For now, our focus is to get familiar with the interface of our primary tool, RStudio. As we saw in Chapter 1, R is the true “computational engine” that allows us to perform calculations, statistical analyses, and various operations. However, the basic interface of R, called Console (see Figure 2.1), is somewhat démodé, or better suited for real experts. Figure 2.1: The R console, only for true connoisseurs In general, RStudio is used for working with R (although it also supports other programming languages, including Python, Stan, C/C++, and JavaScript, among others). RStudio is an Integrated Development Environment (IDE) that includes various tools for writing and executing code into a single Graphical User Interface (GUI). The RStudio interface consists of four main panels (see Figure 2.2): Figure 2.2: RStudio user interface with its four panels Using R through the basic interface (Console alone) versus RStudio is not a debate between two schools of thought (or generations). Both have their advantages and disadvantages and are chosen according to different needs. When looking for maximum optimization, using the basic interface, thanks to its simplicity, helps minimize memory usage by focusing only on the essentials. Thus, using simple R console may ensure faster computation when running large chunks of code. In other cases, however, the additional features and tools in RStudio allow for greater efficiency in your work. 1. Console: the heart R Here we find the Console of R, where all your code and commands are actually executed. Notice how the last line in the Console shows the &gt; symbol. This is called the prompt, indicating that R is waiting for new commands to execute. The Console in R is a command-line interface. Unlike other point-and-click programs, in R, you need to type commands using the keyboard. To execute commands, you can directly type the operations into the Console and press enter. R will immediately execute the command, display the result, and on the next line, the prompt will appear again, indicating that R is ready for a new command (see Figure 2.3). Figure 2.3: Execution of commands directly in the console In the case of multi-line commands, as shown in Figure 2.4, the + symbol appears as the prompt, indicating that R is waiting for the entire command to be typed before it is executed. Figure 2.4: Execution of a multi-line command As you may have noticed during some testing, commands entered in the Console are executed immediately but not saved. To rerun a command, you can scroll through previously executed commands using the arrow keys \\(\\uparrow\\downarrow\\). However, if errors occur, you will need to rewrite and rerun the commands. Since writing code is a continuous try-and-error process, working solely from the Console soon becomes chaotic. Therefore, we need a solution that allows us to work more comfortably with our code and save commands to be executed in the correct order when needed. The solution is Scripts, which we will introduce in the next section. It may happen that, due to a typo in a command or long computational times, the R Console becomes unresponsive. In this case, you need to interrupt the writing or execution of the command. Let’s look at two common situations: The + prompt keeps appearing (instead of &gt;). Especially when using parentheses and long commands, it may happen that after pressing enter, R does not execute any command but stays in wait, showing the + prompt (see the following figure). This is usually due to a syntax error (e.g., a mistake in parentheses or commas). To resume the session, press the esc key on your keyboard. When the prompt &gt; reappears, it indicates that R is ready to listen for new commands, but be careful not to repeat the same mistake. R is unresponsive. Some calculations may take a very long time, or a problem may have caused your session to loop forever. In these situations, the R Console becomes unresponsive. If necessary, you can interrupt the processes currently running by pressing the STOP button, as shown in the following figure. R will stop and return to waiting for new commands (prompt &gt;). In extreme cases where R seems unresponsive, use the Ctrl-C command to force R to stop the running process. As a last resort, remember one of the basic principles of computing: turn-it-off-and-on-again! (i.e., sometimes just closing and reopening RStudio will be enough) 2. Source: your notebook This section displays your Scripts. These are special documents (i.e., documents with the “.R” extension) where your code and commands are saved for future execution in R. Scripts allow you to work comfortably on your code, write commands, correct them, organize them, add comments, and, most importantly, save them. After writing the commands, place the cursor on the same line as the command you want to execute and press Ctrl + enter (Windows) or command + ender (MacOS). The command will automatically be copied into the Console and executed. Alternatively, you can press the Run button indicated by the arrow in Figure 2.5. Figure 2.5: Execute a command from a script by pressing Ctrl + enter (Windows) / command + enter (MacOS), or by pressing the button indicated by the arrow If you looked closely at the script in Figure 2.5, you may have noticed green lines of text preceded by the # symbol. This symbol is used to insert comments into the script. R will ignore any comments and only execute the code. Using comments is very important in complex scripts because it allows us to explain and document the code being executed. In Chapter 6.1.2, we will further explore their usage. To create a new script, simply press the button in the upper left, as shown in the figure, and select “R Script”. Unn nuovo script senza nome verrà creato. Per salvare lo script premere l’icona del floppy e indicare il nome. Ricorda di usare l’estensione “.R” per salvare gli script. 3. Environment and History: the workin session Here you will find a series of panels useful for evaluating information related to your working session. The main panels are Environment and History (the other panels shown in Figure 2.6 concern advanced functions of RStudio). Environment: lists all objects and variables currently present in the working environment. We will explore the concepts of variables and the working environment in Chapter 4.1 and Chapter 5.1, respectively. Figure 2.6: Environment - List of objects and variables in the working environment History: a list of all the commands previously executed in the console. Note that this is not equivalent to a script, rather, it is simply an unmodifiable list (and rarely used). 4. File, Plots, Package, Help: system management This section contains a series of panels used to interface with additional system resources (e.g., files and packages) or to produce outputs such as graphs and tables. Files: a panel where you can browse through all the files on your computer. Figure 2.7: Files - Allows browsing through your computer’s files Plots: the panel where graphs are produced, and which can be exported by clicking Export. Figure 2.8: Plots - Display graphs Packages: a list of R packages (this topic will be covered in more detail in Chapter 5.3). Figure 2.9: Packages - List of R packages Help: used to navigate R’s internal documentation (this topic will be covered in Chapter 4.2.2). Figure 2.10: Help - R documentation RStudio allows a high degree of customization of its graphical interface. You can change the theme, font, and panel layout according to your preferences and needs. Try changing the editor theme to Idle Fingers to use a dark background that is easier on the eyes (see the following figure). Click on RStudio &gt; Preferences &gt; Appearance (MacOS) or Tools &gt; Global Options &gt; Appearance (Windows). "],["first-commands.html", "Chapter3 First steps in R 3.1 Mathematical Operators 3.2 Relational and Logical Operators", " Chapter3 First steps in R Now that we’ve started to familiarize ourselves with our tool of choice, we can finally get down to business and focus on writing code! In this chapter, we will take our first steps in R. We’ll begin by learning how to use mathematical, relational, and logical operators to perform simple operations in R. Learning R is a long journey (spoiler: this journey never really ends since R is constantly evolving). Especially at the beginning, it may seem overly difficult because you’re encountering many programming commands and concepts for the first time. However, once you’ve become familiar with the basics, progress will speed up considerably (unstoppable, we would say!). In this chapter, we will introduce many elements for the first time that will be revisited and explored in greater depth in later chapters. So don’t worry if not everything is clear right away. Learning your first programming language is hard, but you have to start somewhere. Ready for your first lines of code? Let’s become a useR! 3.1 Mathematical Operators R is a great calculator. In Table 3.1, the main mathematical operators and functions used in R are listed. Table 3.1: Table 3.2: Mathematical Operators Function Name Example x + y Addition &gt; 5 + 3 &lt;br /&gt;[1] 8 x - y Subtraction &gt; 7 - 2 &lt;br /&gt;[1] 5 x * y Multiplication &gt; 4 * 3 &lt;br /&gt;[1] 12 x / y Division &gt; 8 / 3 &lt;br /&gt;[1] 2.666667 x %% y Modulo &gt; 7 %% 5 &lt;br /&gt;[1] 2 x %/% y Integer Division &gt; 7 %/% 5 &lt;br /&gt;[1] 1 x ^ y Power &gt; 3 ^ 3 &lt;br /&gt;[1] 27 abs(x) Absolute Value &gt; abs(3-5^2) &lt;br /&gt;[1] 22 sign(x) Sign of an Expression &gt; sign(-8) &lt;br /&gt;[1] -1 sqrt(x) Square Root &gt; sqrt(25) &lt;br /&gt;[1] 5 log(x) Natural Logarithm &gt; log(10) &lt;br /&gt;[1] 2.302585 exp(x) Exponential &gt; exp(1) &lt;br /&gt;[1] 2.718282 sin(x)&lt;br /&gt;cos(x)&lt;br /&gt;tan(x)&lt;br /&gt;asin(x)&lt;br /&gt;acos(x)&lt;br /&gt;atan(x) Trigonometric Functions &gt;sin(pi/2) &lt;br /&gt;[1]1 &lt;br /&gt;&gt;cos(pi/2) &lt;br /&gt;[1]6.123234e-17 factorial(x) Factorial &gt; factorial(6) &lt;br /&gt;[1] 720 choose(n, k) Binomial Coefficient &gt; choose(5,3) &lt;br /&gt;[1] 10 Notice how specific functions are used to perform operations like square root or absolute value. In R, functions are called by typing &lt;function-name&gt;() (e.g., sqrt(25)) and placing the arguments of the function inside the parentheses. We will explore functions in more detail in Chapter 4.2. 3.1.1 Order of Operations When performing operations, R follows the same order used in regular mathematical expressions. Therefore, the precedence of operators is: ^ (power) %% (remainder of a division) e %/% (integer division) * (multiplication) e /(division) + (addition) e -(subtraction) Note that in the presence of functions (e.g., abs(), sin()), R first replaces the functions with their results and then proceeds with the operations in the previously indicated order. The order of operation execution can be controlled by using parentheses ( ). R will perform all the operations inside the parentheses following the same order indicated above. By using multiple groups of parentheses, we can achieve the desired results. Note that in R only round parentheses ( ) are used to manage the order of execution of operations. Square brackets [ ] and curly brackets { } are instead special operators used in R for other purposes, such as selecting elements and defining code blocks. (See also Chapter 7.2) Exercises Calculate the result of the following operations using R: \\(\\frac{(45+21)^3+\\frac{3}{4}}{\\sqrt{32-\\frac{12}{17}}}\\) \\(\\frac{\\sqrt{7-\\pi}}{3\\ (45-34)}\\) \\(\\sqrt[3]{12-e^2}+\\ln(10\\pi)\\) \\(\\frac{\\sin(\\frac{3}{4}\\pi)^2+\\cos(\\frac{3}{2}\\pi)}{\\log_7{e^{\\frac{3}{2}}}}\\) \\(\\frac{\\sum_{n=1}^{10} n}{10}\\) Notes for solving the exercises: In R, the square root is obtained with the function sqrt(), while for roots of different indices, the exponential notation is used (\\(\\sqrt[3]{x}\\) is given by x^(1/3)). The value of \\(\\pi\\) is obtained with pi. The value of \\(e\\) is obtained with exp(1). In R, logarithms use the function log(x, base=a), where the natural logarithm is considered by default. 3.2 Relational and Logical Operators These operations may not seem particularly interesting at the moment, but they will prove very useful later on, for example, for selecting elements (see Chapter 7.2.1). 3.2.1 Relational Operators In R, you can evaluate whether a given relationship is true or false. For example, we can evaluate whether “2 is less than 10” or whether “4 is an even number.” R will evaluate the propositions and return the value TRUE if the proposition is true or FALSE if the proposition is false. In Table 3.3, the relational operators are listed. Table 3.3: Table 3.4: Relational Operators Function Name Example x == y Equal &gt; 5 == 3 &lt;br /&gt;[1] FALSE x != y Not equal &gt; 7 != 2 &lt;br /&gt;[1] TRUE x &gt; y Greater than &gt; 4 &gt; 3 &lt;br /&gt;[1] TRUE x &gt;= y Greater than or equal to &gt; -2 &gt;= 3 &lt;br /&gt;[1] FALSE x &lt; y Less than &gt; 7 &lt; 5 &lt;br /&gt;[1] FALSE x &lt;= y Less than or equal to &gt; 7 &lt;= 7 &lt;br /&gt;[1] TRUE x %in% y inclusion &gt; 5 %in% c(3, 5, 8) &lt;br /&gt;[1] TRUE Be careful that to evaluate the equality between two values, you must use==, not =. This is a very common mistake made frequently. The = operator is used in R to assign a value to a variable. This topic will be covered in Chapter 4.1.1. Note that in any programming language, the values TRUE and FALSE correspond to the numerical values 1 and 0, respectively. These are called boolean values. TRUE == 1 # TRUE TRUE == 2 # FALSE TRUE == 0 # FALSE FALSE == 0 # TRUE FALSE == 1 # FALSE In R, it is also possible to abbreviate TRUE and FALSE as T and F, respectively, although this practice is not recommended as it could generate confusion. Indeed, while TRUE and FALSE are reserved words (see Chapter 4.1.2), T and F are not (i.e., the latter can also serve as names for any other user-defined variables, thus generating confusion). T == 1 # TRUE T == TRUE # TRUE F == 0 # TRUE F == FALSE # TRUE 3.2.2 Logical Operators In R, it is possible to combine multiple relations to evaluate a desired proposition. For example, we could evaluate whether “17 is greater than 10 and less than 20.” To combine multiple relations into a single proposition that R will evaluate as TRUE or FALSE, the logical operators shown in Table 3.5 are used. Table 3.5: Table 3.6: Logical Operators Function Name Example !x Negation &gt; !TRUE &lt;br /&gt;[1] FALSE x &amp; y Conjunction &gt; TRUE &amp; FALSE &lt;br /&gt;[1] FALSE x &amp;#124; y Inclusive Disjunction &gt; TRUE &amp;#124; FALSE &lt;br /&gt;[1] TRUE These operators are also known as boolean operators and follow the common definitions of logical operators. Specifically: In the case of logical conjunction &amp;, for the proposition to be true, both relations must be true. In all other cases, the proposition will be evaluated as false (see Table 3.7). Table 3.7: Table 3.8: Conjunction ‘&amp;’ x y x &amp; y TRUE TRUE TRUE TRUE FALSE FALSE FALSE TRUE FALSE FALSE FALSE FALSE In the case of inclusive logical disjunction |, for the proposition to be true, at least one relation must be true. The proposition will only be evaluated as false when both relations are false (see Table 3.9). Table 3.9: Table 3.10: Inclusive Disjunction ‘|’ x y x &amp;#124; y TRUE TRUE TRUE TRUE FALSE TRUE FALSE TRUE TRUE FALSE FALSE FALSE For completeness, we should mention that there is also the exclusive disjunction among the logical operators. The proposition will be evaluated as false if both relations are either true or false. For the proposition to be evaluated as true, one relation must be true while the other must be false. In R, the exclusive disjunction between two relations (x and y) is indicated with the function xor(x, y). However, this function is rarely used. Exclusive Disjunction ‘xor(x, y)’ x y xor(x, y) TRUE TRUE FALSE TRUE FALSE TRUE FALSE TRUE TRUE FALSE FALSE FALSE 3.2.3 Order of Evaluation of Relations When evaluating the truthfulness of propositions, R executes the operations in the following order: Mathematical operators (e.g., ^, *, /, +, -) Relational operators (e.g., &lt;, &gt;, &lt;=, &gt;=, ==, !=) Logical operators (e.g., !, &amp;, |) The complete list of the order of operation execution is available at the following link https://stat.ethz.ch/R-manual/R-devel/library/base/html/Syntax.html. Remember that if there is any doubt about the order of operation execution, the best thing to do is to use round parentheses ( ) to clarify any possible ambiguities. Note that the %in% operator, which we previously indicated among the relational operators, is actually a special operator. Specifically, it does not follow the same rules as the other relational operators regarding the order of execution. The best solution? Use parentheses! Exercises Perform the following exercises using relational and logical operators: Define two false relations and two true relations that allow you to evaluate the results of all possible combinations using the logical operators &amp; and |. Define a proposition that allows you to evaluate whether a number is even. Define another proposition for odd numbers (hint: what does %% remind you of?). Define a proposition to evaluate the following condition (remember to test all possible scenarios): “x is a number between -4 and -2 or a number between 2 and 4.” Perform the following operations: 4 ^ 3 %in% c(2,3,4) and 4 * 3 %in% c(2,3,4). What do you observe in the order of operation execution? "],["objects-functions.html", "Chapter4 Objects &amp; Functions: Two Inseparable Companions 4.1 Objects 4.2 Functions", " Chapter4 Objects &amp; Functions: Two Inseparable Companions In this chapter, we will introduce the concepts of objects and functions, two fundamental elements of R (and any programming language). We can think of objects in R as variables that allow us to store values in memory (e.g., the results of our calculations or our data). Functions in R, on the other hand, are analogous to mathematical functions that, given objects as input, perform actions and return new objects as output. This is a hyper-simplification (and technically incorrect), but it helps us understand how, starting with our initial data or values, we can manipulate them by applying functions to obtain, through different steps, the desired results (e.g., statistical analyses, graphs, or tables). Here, we will explore the fundamental aspects of using objects and functions, which will be further detailed in the Second Section and the Third Section of the book. 4.1 Objects When we execute a command in R, the result is immediately displayed in the Console. However, this result is not saved in memory, meaning it cannot be reused in any future operations. Conducting analyses in this way would be extremely complicated and inefficient. The most obvious solution is to save our intermediate results in memory so that they can be reused during our analyses. This process is referred to as assigning a value to an object. 4.1.1 Assigning and Calling an Object To assign the numeric value 5 to the object x, the following command must be executed: x = 5 The = operator allows us to assign the values on its right to the object whose name is defined on the left. Therefore, we have the following pattern: &lt;object-name&gt; = &lt;assigned-value&gt;. Notice how in the Console, only the command just executed appears, but no output is shown. To use the value contained in the object, it is sufficient to call the desired object’s name in the code. x + 3 ## [1] 8 It is also possible to “update” or “replace” the value contained in an object. For example: # Update the value of an object x = x*10 x ## [1] 50 # Replace the value of an object x = &quot;Hello World!&quot; x ## [1] &quot;Hello World!&quot; In the first case, we used the old value contained in x to calculate the new result, which was assigned to x itself. In the second case, we replaced the old value of x with a new value (in this example, a character string; note that in this second case, the type of the object x is also changed from numeric to character). There are two main operators used to assign a value to an object: the = operator and the &lt;- operator. Both are valid, and in most cases the choice between them just comes down to personal style. Note that &lt;- is very specific to R, while = is more commonly used across different programming languages. # Demonstration that `=` and `&lt;-` work equally for assigning a value and lead to the same result x_1 = 45 x_2 &lt;- 45 # are they equal? x_1 == x_2 ## [1] TRUE In fact, there may be some good reasons to prefer the use of &lt;- over = (be careful not to confuse the latter with the relational operator ==). The assignment operation implies directionality, which is made explicit by the &lt;- symbol (i.e., what is on the right is assigned to what is on the left), while the = symbol does not explicitly highlight this aspect and even evokes the idea of equality in mathematics, thus potentially generating confusion in the reader. The decision on which operator to adopt is free, but remember that a good programming practice is consistency: once a decision is made, it’s best to stick with it to facilitate understanding of the code. 4.1.2 Object Names Choosing object names may seem like a minor aspect, but it is actually very important for ensuring code clarity and comprehension. There are some rules that distinguish valid names from invalid ones. The name of an object: must start with a letter, and can contain letters, numbers, underscores (_), or periods (.); could also start with a period (.), but in that case, it cannot be followed by a number; must not contain special characters like #, &amp;, $, ?, etc.; must not be a reserved word, meaning words used by R with special meanings (e.g., TRUE, FALSE, etc.; type ?reserved in the Console and press enter for seeing a list of all reserved words in R in the Help panel). Note that R is a Case-Sensitive language, meaning it distinguishes between lowercase and uppercase letters. In the following example, the two names are considered different, so no overwriting occurs, and two different objects are created: My_name = &quot;Monty&quot; my_name = &quot;Python&quot; # are they equal? My_name == my_name ## [1] FALSE Moreover, the ideal name for an object should be: self-descriptive: From the name alone, it should be possible to infer the content of the object. A generic name like x or y would be of little help since they could contain any information. Instead, a name like weight or gender would clearly suggest the content of the object (e.g., the weight or gender of the participants in our study). of the right length: It should not be too short (avoiding incomprehensible abbreviations) but not too long either. The correct length allows the name to be sufficiently informative without adding unnecessary details. Typically, 2 or 3 words are enough. Often, more than one word is used to create a sufficiently clear name. However, since spaces cannot be included in a name, the issue arises of how to combine multiple words without making the name incomprehensible, such as mediatestcontrol. There are several conventions, including: CamelCase. The start of a new word is indicated by using an uppercase letter. For example, mediaTestControl. snake_case. The start of a new word is indicated by using the _ character. For example, media_test_control. a variation of the classic snake_case involves using ., for example, media.test.control. This latter approach is not recommended, however, because in many programming languages (including R itself under certain conditions), the . character is a special character. Generally, it is recommended to follow the snake_case convention. However, the decision on which convention to adopt is free, but remember again that a good programming practice is consistency: once a decision is made, it’s best to stick with it to facilitate understanding of the code. 4.1.3 Data Types and Data Structures To work optimally in R, it is essential to be well-acquainted with and clearly distinguish between the different data types and structures used. In R, we have four main data types, which are types of values that can be used: character - Character strings whose alphanumeric values are enclosed in double quotes like \"Hello world!\" or single quotes like 'Hello world!'. double - Real numerical values with or without decimal points, such as 27 or 93.46. integer - Integer numerical values defined by appending the letter L to the desired number, such as 58L. logical - Logical values TRUE and FALSE used in logical operations. If you want to know the data type of a value or variable you can use the typeof() function as follows: typeof(&quot;Psicostat&quot;) ## [1] &quot;character&quot; typeof(24.04) ## [1] &quot;double&quot; typeof(1993L) ## [1] &quot;integer&quot; typeof(TRUE) ## [1] &quot;logical&quot; In R, we also have different types of objects, or structures in which data can be organized: Vectors Matrices Dataframes Lists We will explore their definition, characteristics, and usage in more detail throughout the Second Section of this book. 4.2 Functions We can think of functions in R as being similar to classic mathematical functions. Given input values, functions perform specific calculations and return the obtained result as output. We have already encountered our first functions for performing specific mathematical operations in Chapter 3.1, such as sqrt() or abs(), used to obtain the square root or absolute value of a number, respectively. Of course, functions in R are not limited to mathematical calculations; they can perform any kind of task, such as creating graphs and tables or manipulating data or files. However, the concept remains the same: given objects as input, functions perform certain actions and return new objects as output. In fact, we will encounter functions that require no input or produce no output. For example, getwd() requires no input (it just tells you the filepath representing the current working directory of R), or the function rm() produces no output (it just removes one or more objects that you pass as its input). However, this occurs in a minority of cases. 4.2.1 Function Arguments The function input is called “arguments”. Generally, to execute a function in R, you need to type the function’s name and indicate in parentheses the values (input) you want to assign to the function’s arguments, separated by commas. The following general syntax is used: &lt;function-name&gt;(&lt;name-arg1&gt; = &lt;value-arg1&gt;, &lt;name-arg2&gt; = &lt;value-arg2&gt;,...) For example, to create a sequence of values with increments of 1, you can use the seq() function, whose arguments include (among others) from, to, and by, indicating the starting value, the maximal value of the sequence, and the increment respectively. # create a sequence of values from 0 to 10 with increments of 2 seq(from = 0, to = 10, by = 2) ## [1] 0 2 4 6 8 10 When defining a function’s arguments, it is not necessary to specify the names of the arguments. For example, the previous command can also be executed by specifying only the values. # create a sequence of values from 0 to 10 with increments of 2 seq(0, 10, 2) ## [1] 0 2 4 6 8 10 However, this makes reading and understanding the code more difficult because it is unclear which arguments the values refer to. In this case, the order in which the values are defined is important, as R assumes the predefined order of the arguments. Notice how swapping the values produces different results from the previous ones, but this does not happen when the argument names are specified. # swap previous values without specifying the argument names # (so it will try going from 0 to 2 with increments of 10) seq(0, 2, 10) ## [1] 0 # swap previous values, but specifying the argument names seq(from = 0, by = 2, to = 10) ## [1] 0 2 4 6 8 10 We also see that functions can have many arguments, but it is not (always) necessary to specify the value for each one. Many arguments, in fact, have preset some default values and do not need to be specified unless, of course, you want to use settings different from the default. Additionally, specifying one argument over another can define the function’s behavior. For example, the seq() function also has the length.out argument, which was not specified earlier. It allows you to define the number of elements in the sequence. Let’s see how specifying length.out changes the function’s behavior. seq(from = 0, to = 10, length.out = 5) ## [1] 0.0 2.5 5.0 7.5 10.0 seq(from = 0, to = 10, length.out = 5, by = 2) ## Error in seq.default(from = 0, to = 10, length.out = 5, by = 2): too many arguments In the second case, specifying both length.out and by produces an error, because the two arguments try to impose incompatible and contradictory request to the function’s behavior (i.e., with length.out = 5 five numbers are requested as output, but this is incompatible with by = 2 which would generate six numbers as output from 0 to 10). In general, it is advisable to always explicitly specify a function’s arguments to make it clear what the indicated values refer to, while ensuring that the arguments do not conflict with each other. This is also useful to avoid unwanted function behaviors and to more easily identify potential errors. Moreover, a function’s arguments require specific types and structures of data, and it is up to us to ensure that the data is provided in the correct manner. For example, the mean() function, which calculates the average of a set of values, requires a vector of numeric values as input. We will explore the concept of vectors in Chapter 7, but for now, we just need to know that we can use the c() function to combine multiple values into a single vector. # Calculate the average of the following numeric values # use c() to combine multiple values into a single vector mean(c(10, 80, 60, 120)) ## [1] 67.5 mean(10, 80, 60, 120) ## [1] 10 Notice how in the first case the result is correct, while in the second case it is wrong. This is because mean() requires a vector as the first argument. In the first case, we correctly specified the vector of values using the c() function. In the second case, however, the first argument is just the value 10, and R calculates the average of 10 itself which is, of course, 10. The remaining values are just passed to other arguments that do not alter the behavior but also fail to flag this major error. In the following example, we can see how mean() requires the values to be numeric. Although \"1\", \"2\", and \"3\" look like numbers, using double quotes turns them into character strings rather than numeric values, and R cannot calculate an average for characters. # Calculate the average of the following (character) values mean(c(&quot;1&quot;, &quot;2&quot;, &quot;3&quot;)) ## Warning in mean.default(c(&quot;1&quot;, &quot;2&quot;, &quot;3&quot;)): argument is not numeric or logical: ## returning NA ## [1] NA We understand, therefore, that to correctly use functions, it is essential to know their arguments and respect the required data types and structures. 4.2.2 Help! I need Somebody…Help! It is impossible to know all the functions and all their arguments. Fortunately, R helps us by easily providing documentation for each function. This documentation includes all the information regarding the function’s purpose, a description of its arguments, and details about its possible uses. To access the documentation, we can use the command ?&lt;function-name&gt; or help(&lt;function-name&gt;). For example: ?seq help(seq) A page will open in the “Help” panel in the bottom right with the function’s documentation, similar to what is shown in Figure 4.1. Figure 4.1: Help-page for function seq() The format and information on the page follow common but not mandatory standards. In fact, not all fields are always used, and the function’s author has some degree of freedom in customizing the documentation. The main and most commonly used fields include: Title - Explanatory title of the function’s purpose; Description - Concise description of the function; Usage - Displays the function’s structure with its arguments and default values; Arguments - List with detailed descriptions of all the arguments. Here, we find both the available options and their effects, as well as the required data types; Details - Detailed description of the function, including usage cases and technical notes; Value - Description of the function’s output. This includes a description of the data structure of the output and the interpretation and use of the obtained results; See Also - Links to other similar or related functions; Examples - Examples of how to use the function. Word Search When you don’t know the exact name of a function or want to search for all functions and pages that include a certain word, you can use the command ??&lt;word&gt; or help.search(&lt;word&gt;). R will perform a search across all available documentation and provide a list of pages that contain the desired word in the title or keywords. Programmers tend to be lazy and forgetful. Fortunately, every respectable code editor (i.e., a program for writing code) has helpful autocomplete and command suggestion functions that simplify code writing. In RStudio, suggestions appear automatically while typing a command, or they can be triggered by pressing the Tab key at the top left of the keyboard ( ). A window will appear with possible autocomplete suggestions for the function name. Using the arrow keys, we can highlight the desired function and press enter to autocomplete the command. Notice how a small yellow box with the function’s description appears next to the function name. To insert the function’s arguments, we can again rely on suggestions and the autocomplete function. Simply press the Tab key again, and this time a list of arguments with descriptions will appear. We can then select the desired argument with the arrows and press enter. Notice how the autocomplete function is not only used for functions but also for object names. This allows us to quickly recall previously created objects without typing the entire name. "],["working-environment.html", "Chapter5 Working Environment 5.1 Environment 5.2 Working Directory 5.3 R-packages", " Chapter5 Working Environment In this chapter, we will introduce some very important concepts related to the working environment in R or RStudio. Specifically, we will talk about the environment, the working directory, and the use of packages. 5.1 Environment In Chapter 4.1, we saw how it is possible to assign values to objects. These objects are created in our working environment (or more precisely, Environment) and can be used later. Our Environment collects all the objects that are created during our work session. You can check the objects currently present by looking at the Environment panel in the top right (see Figure @ref(fig )) or by using the command ls(), which stands for list objects. Figure 5.1: Environment - List of objects and variables present in the workspace At the beginning of the work session, our Environment will be empty (see Figure 5.2). The ls() command will not return any object but will use the response character(0) to indicate the absence of objects, which is a zero-length character vector (see Chapter 7). Figure 5.2: Empty Environment at the start of the working session # Empty Environment ls() ## character(0) 5.1.1 Adding Objects to the Environment Once objects are created, they will be present in our Environment, and the ls() command will return a character vector listing all their names. # Create objects x = c(2,4,6,8) y = 27 word = &quot;Hello Word!&quot; # List object names in the Environment ls() ## [1] &quot;word&quot; &quot;x&quot; &quot;y&quot; In the top right panel (see Figure 5.3), we can find a list of the objects currently present in our Environment. Along with the name, some useful information depending on the type of object is provided. As we can see in our example, for variables with a single value (e.g., word and y), the actual values are presented. In the case of vectors (e.g., x), information about the type of vector and its size is also provided (see Chapter 7). In the example, we have a numeric vector (num) with 4 elements ([1:4]). Figure 5.3: Environment containing the created objects 5.1.2 Removing Objects from the Environment To remove an object from the environment, you can use the remove() command or its abbreviation rm(), specifying the object’s name in parentheses. Multiple objects can be specified, separating their names with a comma. # Remove an object rm(word) ls() ## [1] &quot;x&quot; &quot;y&quot; # Remove multiple objects at once rm(x,y) ls() ## character(0) If you need to delete all the objects currently present in your working environment, you can use the command rm(list=ls()). This will ensure that the environment is cleared of all objects, restoring it to its initial session conditions. Keeping your Environment organized and being aware of the objects currently present is important. This helps avoid two common errors. Using objects that have not yet been created. In this case, the error is easy to spot because R will warn us with “object ‘’ not found”. You simply need to execute the command to create the requested object. my_object ## Error in eval(expr, envir, enclos): object &#39;my_object&#39; not found Using objects with “old” values. If you don’t keep your environment organized, it may happen that different objects are created during successive work sessions. At this point, you might lose track of the real content of the objects and end up using objects assuming they contain certain values when, in fact, they contain something else. This would make any result meaningless. Be very careful because R cannot warn you about this error (for R, they are just numbers); you must be aware of whether the executed commands make sense or not. To maintain an organized Environment, we recommend not automatically saving your workspace when you end a work session. You can set this option in R’s general settings by selecting “Never” for the “save workspace to .RData on exit” option, as shown in the following Figure. This will allow you to start each new work session in an empty Environment, preventing old objects from accumulating over multiple sessions. Additionally, during your sessions, it will be helpful to run the rm(list=ls()) command when you begin a new task to remove all the old objects. Environment as Short-Term Memory The Environment is something temporary. Objects are saved in the computer’s primary memory (RAM, which we can think of as similar to Short-Term Memory in cognitive models) and will be deleted with the rm(list=ls()) command or at the end of each work session. Starting each session with an empty Environment will force you to gather all the steps of your analysis in an orderly script, avoiding reliance on old objects. All the objects needed during analyses will have to be recreated in each session, ensuring reproducibility and correctness (at least from a programming perspective). Ideally, in a work session, you should be able to start from an empty Environment and execute all the commands in a script in order to obtain the desired results. It is easy to see how this is not always the most efficient solution. Some commands might take many minutes (or even days) to execute. In these cases, it would be convenient to save the results obtained so they can be used in subsequent sessions without the need to re-run all the commands. In Chapter TODO, we will see how to permanently save the created objects to the computer’s secondary memory (hard drive, analogous to long-term memory in our analogy) and how to load them in a subsequent work session. 5.2 Working Directory The concept of a working directory is very important but often not well understood. The working directory is the location within the computer where we are during our work session and from which we execute our commands. 5.2.1 Computer Organization The intuitive idea we commonly have about how a computer works is misleading. We often think the Desktop reflects the organization of the entire computer and that all actions are managed through the point-and-click interface to which modern operating systems have accustomed us. Without going into detail, it is more accurate to think of a computer’s organization as a system of folders and subfolders containing all our files and of its functioning as a set of processes (or commands) being executed. The programs we install are nothing more than folders containing all the scripts that determine their functioning. Even the Desktop is just a simple folder, while what we see is a program defined by the operating system that displays the folder’s contents on our screen and allows us to interact with it using the mouse. Everything present on our computer, including our files, programs, and the operating system itself, is organized in an elaborate system of folders and subfolders. Approximately, we can think of the computer’s organization as shown in Figure 5.4 (from: https://en.wikipedia.org/wiki/Operating_system). Tutto quello che è presente nel nostro computer, compresi i nostri file, i programmi e lo stesso sistema operativo in uso, tutto è organizzato in un articolato sistema di cartelle e sottocartelle. Approsimativamente possiamo pensare all’organizzazione del nostro computer in modo simile alla Figura 5.4 (da: https://en.wikipedia.org/wiki/Operating_system). Figure 5.4: Computer organization (from Wikipedia) At the lowest levels, we find all the system files, which users can access only with special permissions. At the higher levels, we find all the files related to the installed programs and applications, which are generally usable by multiple users on the same computer. Finally, we find all the folders and files related to the specific user. 5.2.2 Absolute Path and Relative Path This long preamble about the folder and subfolder organization is necessary because it is the structure the computer uses to navigate among all the files when executing commands through a command-line interface (e.g., R). If, for example, we want to load data from a specific file in R, we must provide the correct path (or address) that tells us exactly where the file is located within the computer’s folder structure. For example, let’s imagine we have data My-data.Rda saved in the Introduction2R folder on the Desktop. Desktop/ | |- Introduction2R/ | | | |- Dati/ | | |- My-data.Rda To indicate the file’s location, I could use either an: absolute path - the file’s “absolute” location relative to the system’s root directory, which is the main folder of the entire computer. # Mac &quot;/Users/&lt;username&gt;/Desktop/Introduction2R/Dati/My-data.Rda&quot; # Windows Vista &quot;c:\\Users\\&lt;username&gt;\\Desktop\\Introduction2R\\Dati\\My-data.Rda&quot; relative path - the file’s location relative to our current position in the computer from which we are executing the command, i.e., relative to the working directory of our work session. Continuing the previous example, if our working directory were the Desktop/Introduction2R folder, we would have the following relative paths: # Mac &quot;Dati/My-data.Rda&quot; # Windows Vista &quot;Dati\\My-data.Rda&quot; Notice how using relative paths is preferable because absolute paths are unique to the specific computer in question and therefore cannot be used on other computers. If you use a relative path to indicate a file’s location, it is important that the current working directory is indeed the one you expect. If we were in a different folder, the indicated “relative path” would no longer be valid, and R would show us an error message. Returning to the previous example, let’s suppose our current working directory is Desktop instead of Desktop/Introduction2R. Running the load() command to load the data using the now-invalid relative path would result in: load(&quot;Dati/My-data.Rda&quot;) ## Warning in readChar(con, 5L, useBytes = TRUE): cannot open compressed file ## &#39;Dati/My-data.Rda&#39;, probable reason &#39;No such file or directory&#39; ## Error in readChar(con, 5L, useBytes = TRUE): cannot open the connection The error message indicates that R was unable to find the file based on my directions. It’s as if I asked the computer to open the fridge, but it was currently in the bedroom; I need to give it directions to the kitchen, or else it would reply “fridge not found”. It is therefore crucial always to be aware of the current working directory where the session is being held. Of course, I would get the same error using an absolute path if it contained errors. As you may have noticed from the previous examples, both the structure used to organize files on the computer and the syntax used to define paths differ depending on the operating system used. Mac OS e Linux The character used to separate folders in the path definition is \"/\": &quot;Introduction2R/Dati/My-data.Rda&quot; The root-directory is indicated by starting the path with the \"/\" character: &quot;/Users/&lt;username&gt;/Desktop/Introduction2R/Dati/My-data.Rda&quot; The user’s home directory (i.e., /Users/&lt;username&gt;/) is indicated by starting the path with the \"~\" character: &quot;~/Desktop/Introduction2R/Dati/My-data.Rda&quot; Windows The character used to separate folders in the path definition is \"\\\": &quot;Introduction2R\\Dati\\My-data.Rda&quot; The root-directory is indicated by \"c:\\\": &quot;c:\\Users\\&lt;username&gt;\\Desktop\\Introduction2R\\Dati\\My-data.Rda&quot; 5.2.3 Working Directory in R Now let’s see the commands used in R to check and change the working directory during your session. Note that in the following examples, in R, the \"/\" character is always used to separate folders in the path definition, regardless of the operating system. Current Working Directory In R, you can check the current working directory using the getwd() command, which will return the absolute path of the current location. getwd() ## [1] &quot;/Users/&lt;username&gt;/Desktop/Introduction2R&quot; Alternatively, the current working directory is also displayed in the top left of the Console, as shown in Figure 5.5. Figure 5.5: Working directory of the current working session By clicking the arrow next to it, the Files panel in the bottom right will be redirected directly to the working directory of the current session. This makes it easy to navigate through the files and folders contained within it (see Figure 5.6). Figure 5.6: Working directory of the current working session Changing the Working Directory Per cambiare la working directory è possibile utilizzare il comando setwd() indicando il path (absolute o relative) della nuova working directory. Nota come, nel caso in cui venga indicato un relative path, questo dovrà indicare la posizione della nuova working directory rispetto alla vecchia working directory. getwd() ## [1] &quot;/Users/&lt;username&gt;/Desktop/Introduction2R&quot; setwd(&quot;Data/&quot;) getwd() ## [1] &quot;/Users/&lt;username&gt;/Desktop/Introduction2R/Data&quot; Alternatively, you can select the “Choose Directory” option from the “Session” &gt; “Set Working Directory” menu, as shown in Figure 5.7. You will then be prompted to select the desired working directory and press “Open”. Figure 5.7: Setting the working directory Note that you can take advantage of auto-completion when typing the path. Inside the quotes \"\", press the Tab key to see suggestions for paths relative to the current working directory. Additionally, you can use the special characters \"./\" and \"../\" to refer to the current working directory and the parent folder (i.e., the folder that contains the current working directory), respectively. \"../\" allows us to navigate backward from our current location through the computer’s folder structure. getwd() ## [1] &quot;/Users/&lt;username&gt;/Desktop/Introduction2R&quot; setwd(&quot;../&quot;) getwd() ## [1] &quot;/Users/&lt;username&gt;/Desktop/&quot; 5.3 R-packages One of the great strengths of R is the ability to extend its basic functions easily and intuitively by using new packages. Currently, there are over 19,000 packages freely available on CRAN (the official R repository). These packages have been developed by R’s immense community to perform all sorts of tasks. You could say that in R, anything is possible if you find the right package (or create it!). When we installed R, a set of packages was automatically installed that make up the system library, which includes all the basic packages that allow R to function. However, other packages are not immediately available. To use the functions of other packages, a two-step procedure is required, as represented in Figure 5.8: Download and install the packages on your computer. The packages are freely available online in the CRAN repository, a sort of archive. They are then downloaded and installed in our library, which is the collection of all R packages available on our computer. Load the package into the work session. Even though the package is installed in our library, we are not yet ready to use its functions. First, we need to load the package into our work session. Only then will the package’s functions be available for use. Figure 5.8: Using the R packages This two-step procedure might seem unintuitive. “Why do we need to load something that is already installed?” The answer is simple: it helps keep our work session efficient and under control. In fact, we will never need all the installed packages, but depending on the tasks we need to perform, we will use only a few specific packages at a time. If all the packages were loaded automatically every time, it would be an unnecessary waste of memory, and conflicts would easily arise. Some functions from different packages might have the same name but different purposes. This could easily lead to errors or invalid results. Now, let’s see how to perform these operations in R. 5.3.1 install.packages() To install packages from CRAN into our library, you can use the install.packages() command, specifying the name of the desired package in parentheses. # A great package for statistical analysis by John Fox # a great statistician... known as Jonny the fox to friends ;) install.packages(&quot;car&quot;) Alternatively, you can use the “Install” button in the top left of the Packages panel (see Figure 5.9), then specify the name of the desired package. Figure 5.9: Installing packages via the RStudio interface Note that installing a package might also require installing other packages. This is because the package’s dependencies (i.e., all the packages used internally by the package of interest and necessary for its proper functioning, like a Matryoshka doll) will automatically be installed. Once the package is installed, it will appear in the library, which is the list of available packages shown in the Packages panel (see Figure 5.10). Figure 5.10: The car packages is now available in the library When installing packages, R might display a message similar to the following: There are binary versions available but the source versions are later: binary source needs_compilation devtools 1.13.4 2.0.1 FALSE [... una lista di vari pacchetti...] Do you want to install from sources the packages which need compilation? In short, the answer to give is NO (\"n\"). But what is R actually asking? Packages are available in different formats, the most common being: Binary Version - ready to use and easy to install; Source Version - requires a particular procedure called compilation to install. In general, it’s always preferable to install the Binary version. However, in this case, R is warning us that for some packages, the most recent updates are only available in the Source version and is asking if we want to install them via the compilation procedure. It’s preferable to respond “no”, installing the ready-to-use Binary version, even if it is slightly outdated. If you are required to install a package in the Source version (either because you need the latest updates or because it’s not available otherwise), you must first install R tools (see “In-Depth: R Tools” in Chapter 1.1), which provides the necessary tools to compile the packages. For a detailed discussion, see https://community.rstudio.com/t/meaning-of-common-message-when-install-a-package-there-are-binary-versions-available-but-the-source-versions-are-later/2431 e https://r-pkgs.org/package-structure-state.html 5.3.2 library() To use the functions of a package already present in our library, we now need to load it into our work session. To do this, we can use the library() command, specifying the name of the required package in parentheses. library(car) Alternatively, you can check the box to the left of the package name in the Packages panel, as shown in Figure 5.11. However, this procedure is not recommended. In fact, every point-and-click action must be performed in every session, while using commands included in the script ensures their automatic execution. Figure 5.11: Loading a package in the working session Now we are finally ready to use the package’s functions in our work session. There is a little trick to using a specific function from a package without having to load the package into your session. To do this, you can use the syntax: &lt;nome-pacchetto&gt;::&lt;nome-funzione&gt;() # Example with the Anova function from the car package car::Anova() Using :: allows us to call the desired function directly. The difference between using library() and :: concerns some fairly advanced aspects of R (for further details, see https://r-pkgs.org/namespace.html). In short, we can say that in some cases, it’s preferable not to load an entire package if you only need one function from it. 5.3.3 Updating and Removing Packages Just like any other software, packages are updated over time, providing new features and fixing any issues. To update packages to the most recent version, you can run the update.packages() command without specifying anything in parentheses. Alternatively, you can press the “Update” button in the top left of the Packages panel (see Figure 5.12), then specify the packages you want to update. Note how the current version is listed under the “Version” column in the list of packages. Figure 5.12: Updating packages If you want to remove a specific package, you can run the remove.packages() command, specifying the package’s name in parentheses. Alternatively, you can press the x button to the right of the package in the Packages panel, as shown in Figure 5.13. Figure 5.13: Removing packages 5.3.4 Package Documentation Each package includes documentation for its functions and vignettes, which are short tutorials showing examples of the package’s use. Function documentation - To access a function’s documentation, you can use the command ?&lt;function-name&gt; or help(&lt;function-name&gt;). Remember, you must first load the package; otherwise, the function will not be available yet. Alternatively, you can broaden the search using the ?? command. Vignettes - To get a list of all vignettes for a particular package, you can use the command browseVignettes(package = &lt;package-name&gt;). To access a specific vignette, use the vignette(\"&lt;vignette-name&gt;\") command. Entire package documentation - Clicking on the package name in the Packages panel in the bottom right will open the list of all information related to the package, as shown in Figure 5.14. Links to vignettes and other files related to the package’s features are provided first. Then, all the functions are listed in alphabetical order. Figure 5.14: Documentation of the ‘car’ package However, remember that the biggest source of information is always Google. Many important packages even have their own website, where they collect a lot of useful material. Nonetheless, many tutorials and examples are always available online. CRAN is not the only resource where you can install R packages, but it is the official one and guarantees a certain standard and stability for the packages it hosts. There are many other repositories online that collect R packages (and software in general), with one of the most popular being GitHub (https://github.com/). Github is used as a development platform for many R packages, so it’s possible to find the latest development versions of packages there, with the most recent updates, or even new packages not yet available on CRAN. However, it’s important to note that these are development versions and may have more issues. Additionally, installing packages this way requires the installation of R tools (see “In-Depth: R Tools” in Chapter 1.1). To install a package directly from Github, you can use the install_github() command from the devtools package, specifying the URL of the desired repository. install.packages(&quot;devtools&quot;) # ggplot2 the best package for graphics devtools::install_github(&quot;https://github.com/tidyverse/ggplot2&quot;) "],["working-session.html", "Chapter6 Working Session 6.1 Organizing Scripts 6.2 Organizing Projects 6.3 Messages, Warnings e Errors", " Chapter6 Working Session In this chapter, we will discuss some general aspects of working sessions in R. We will describe good habits for organizing scripts to be neat and efficient in your work. We will also explain how to organize your projects in folders, particularly introducing the use of RStudio Projects. Finally, we will go over how to handle R messages, particularly how to deal with errors. 6.1 Organizing Scripts We have seen that ideally, all the steps of our analyses should be organized neatly within a script. By running commands line by line in sequence, it should be possible to perform all analyses until the desired results are achieved. Let’s now go over a set of good practices for organizing code neatly within a script and making it easier to read. 6.1.1 Creating Sections To keep the script’s organization clear and easy to understand, it is useful to divide the code into sections where different steps of the analysis are performed. In RStudio, you can create a section by adding the characters #### or ---- at the end of a comment line. The comment text will be considered the section title, and a small arrow will appear next to the line number. You can use either # or - characters to create the desired style, as long as the line ends with at least four identical characters. # Section 1 #### # Section 2 ---- #---- Section 3 ---- #### Invalid Section --## As a simple example, let’s look at a section division used in the script in Figure 6.1. Figure 6.1: Example of dividing a script into sections Title - A descriptive title of the script’s content. You can use other characters within comments to create the desired effect. Introduction - A description and useful information regarding both the work’s objective and code execution (e.g., where the data is available, any technical specifications). It may also be useful to include the author and date of the work. Setting - A key section where you set up the working environment. The steps to follow are: rm(list = ls()) to clear the Environment of any objects so the script starts from a clean environment (see Chapter 5.1). setwd() to set the working directory, ensuring the commands are executed from the correct location on your computer (see Chapter 5.2). library() to load the packages used in the analyses (see Chapter @ref(packages)). Loading and Cleaning Data - A general section for importing and cleaning data. Coding and Scoring Data - A general section for coding and potentially scoring data. Descriptive Analysis - A general section for performing descriptive analyses. Inferential Analysis - A general section for performing inferential analyses. Besides keeping your code neat and clear, dividing your script into sections allows you to easily navigate between different parts of the code. You can use the index that is automatically created. The index is accessible by clicking the button at the top right of the script and selecting the desired section (see Figure 6.2). Figure 6.2: Index at the top for section navigation Alternatively, you can use the menu at the bottom left of the script (see Figure 6.3). Figure 6.3: Bottom menu for section navigation Finally, another advantage is the ability to collapse or expand code sections in the editor by using the arrows next to the line numbers (see Figure 6.4). Figure 6.4: Compacting and expanding code sections 6.1.2 Syntax Here are some additional good practices for writing code that make it easier to understand. Comments The use of comments is very important. It allows us to document the different parts of the code and clarify any difficult-to-understand commands. However, it’s not necessary to comment on every single line of code, and it’s better to avoid commenting when commands are easily interpretable by simply reading the code. The ability to write useful comments and avoid redundant ones comes with experience. In general, a comment should not indicate “what” but rather the “why” of that part of the code. The “what” is easily interpretable from the code itself, while the “why” may be less obvious and much more helpful for understanding the entire script. For example: x = 10 # assign the value 10 to x x = 10 # define maximum number of responses The first comment is unnecessary because it is easily understandable from the code itself, while the second comment is very useful because it clarifies the meaning of the variable and will help in understanding the code. Object Names We discussed in Chapter 4.1.2 the rules that distinguish valid from invalid names and the conventions to follow when defining a name. Here, we recall the characteristics that a name should have to make the code easier to understand. The name of an object should be: Self-descriptive - From the name alone, it should be possible to infer the object’s contents. It’s better to avoid generic names (such as x or y) and instead use names that clearly describe the content of the object. Of appropriate length - It should neither be too short (avoiding incomprehensible acronyms) nor too long. Usually, 2 or 3 words are enough to clearly describe an object. It’s also important to be consistent in the choice of style when naming variables. Generally, it is preferable to use snake_case over CamelCase, but the choice is up to you. However, once a decision is made, it’s best to stick with it to facilitate the understanding of the code. Explicitly Name Arguments We discussed in Chapter 4.2.1 the importance of explicitly naming arguments when using functions. Specifying what each value refers to makes reading and understanding the code easier. For example: seq(0, 10, 2) It may not be clear whether we mean a sequence between 0 and 10 of length 2 or at intervals of 2. By specifying the arguments, we avoid confusion and possible errors. seq(from = 0, to = 10, by = 2) seq(from = 0, to = 10, length.out = 2) Spaces, Indentation, and Alignment Unlike many other software, R does not enforce strict rules regarding the use of spaces, indentation, and alignment, and it is generally very permissive in terms of syntax. However, it is important to remember that: Good coding style is like using correct punctuation. You can manage without it, but it sure makes things easier to read - Hadley Wickham Take, for example, the following lines of code, which include some advanced R functions: # Style 1 k=10;if(k&lt;5){x=5:15}else{x=seq(0,16,4)};y=7*2-12;mean(x/y) ## [1] 4 # Style 2 k = 10 if (k &lt; 5){ x = 5:15 } else { x = seq(from = 0, to = 16, by = 4) } y = 7 * 2 - 12 mean(x / y) ## [1] 4 As you can see, we get the same results in both cases, and for R, there is no difference. However, the use of spaces, correct indentation, and appropriate alignment makes the code easier to read and understand. Generally, the following rules apply: Add spaces around operators (+, -, =, &lt;-, etc.) to separate them from arguments, except for : # Good 35 / 5 + 7 x = 0:10 # Bad 35/5+7 x=0 : 10 In functions, add spaces around the = symbol that separates the argument names from their values. Add a space after each comma but do not separate the function name from the opening parenthesis. # Good seq(from = 0, to = 10, by = 2) # Bad seq (from=0,to=10,by=2) Use correct indentation for code blocks within curly braces. The level of indentation should reflect the nested structure of the code. # Good for (...) { # outer loop ... for (...) { # inner loop ... if (...) { # conditional statement ... } } } # Bad for (...) { # outer loop ... for (...) { # inner loop ... if (...) { # conditional statement ... } } } Align function arguments if they span multiple lines. # Good data.frame(id = ..., name = ..., age = ..., sex = ...) # Bad data.frame(id = ..., name = ..., age = ..., sex = ...) You can find more rules and tips regarding coding style at the following link https://irudnyts.github.io/r-coding-style-guide/ 6.2 Organizing Projects As the complexity of an analysis grows, you will soon need to manage many files of different types (e.g., data, reports, charts) and split various parts of the work into different scripts. At this point, it will be important to organize all the materials needed for the analysis and the related results in one folder. Ideally, each analysis will be saved in a different folder, and you can, for example, organize the files using the following folder structure: My_analysis/ |- Data/ |- Documents/ |- Outputs/ |- R/ Data/ - all files related to the data used in the analysis. It is important to keep both a copy of the raw data, which is the unmanipulated data, and the actual data used in the analysis, which has usually been cleaned and coded. Documents/ - all text files (e.g., Word or similar) and reports used to describe the analyses (see especially R-markdown). Outputs/ - any outputs created during the analyses, such as charts and tables. R/ - all scripts used for the analyses. You can number the scripts to suggest the correct order in which they should be executed, for example, 01-import-data.R, 02-munge-data.R, 03-descriptive-analysis.R, etc. This structure is purely illustrative, but it can be a useful starting point that can be adapted depending on the particular needs of each project. 6.2.1 RStudio Projects RStudio also allows you to create R Projects, which are workspaces that allow you to manage different projects independently. Each project will have its own working directory, workspace, history, and personalized settings. This makes it easy to switch between projects and immediately resume where you left off without worrying about other tasks. Let’s see how to create an R Project. Select File &gt; New Project… Select New Directory to create an R Project in a new folder (alternatively, select Existing Directory to create an R Project in an existing folder) Select New Project (in advanced usage, you can choose specific templates to use) Specify the folder name (which will also be the name of the R Project) and the location where the folder will be created Once the project is created, RStudio will open the project directly. Note that the RStudio icon will now include the name of the currently open project To close a project, simply select File &gt; Close Project or use the menu in the top right corner To open a previous project, simply select File &gt; Open Project or double-click the .Rproj file in the project folder Now, let’s list some of the main advantages of using R Projects: The working directory is automatically set to the project folder. This means you no longer need to worry about defining it, and you can define every path relative to the project folder. When you open a project in a subsequent work session, the scripts and working documents will automatically open as you left them in the previous session. It’s like having a desk for each project where you can leave all the useful documents and immediately resume working. Using projects allows you to customize and automate many functions, such as loading packages or running certain codes. However, this requires a good understanding of R. There are many templates for projects that implement useful features. In particular, the structure of R Projects used for package development is very useful, even in the case of statistical analyses. However, this requires a good knowledge of R. 6.3 Messages, Warnings e Errors R uses the console to communicate with us during our work sessions. In addition to providing the results of our commands, R also sends us other useful information through different types of messages. In particular, we have: Messages: simple messages that can update us, for example, on the progress of a task or provide suggestions on how to use a specific function or package (often shown when a package is loaded). Warnings: these messages are used by R to tell us that something strange has happened that has alerted R. R warns us that while the command was executed and we obtained a result, there were unusual behaviors or possibly automatic corrections applied. In the case of warnings, there’s no need to panic; it is important to check that the commands are correct and that we have obtained the desired result. Once sure of the results, we can proceed confidently. Errors: R informs us of any errors or problems that prevent the command from being executed. In this case, we will not get any results, but we must understand and resolve the problem before rerunning the command and proceeding. We can see that not all the messages R sends are error messages. Therefore, it is important not to panic but to carefully read the messages. Many times, they are simply warnings or suggestions. However, errors are always the biggest problem because you cannot proceed with the work without resolving them first. It’s important to remember that error messages are not criticisms from R for our mistakes. On the contrary, they are requests for help from R because it doesn’t know what to do. As powerful as R is, it’s still a simple program that cannot interpret our requests but relies on commands that follow a strict syntax. Sometimes, a missing comma or a character instead of a number can confuse R and require our intervention to fix it. 6.3.1 Resolving Errors When writing code, even simple code, one thing that will surely happen frequently is encountering error messages and finding ways to resolve them. Some experienced programmers would say that the essence of programming is actually resolving the errors that the code produces. Errors are not a defect or an unexpected event, but an integral part of writing code. What’s important is learning how to handle them. We’ve all seen images in movies of programmers typing code at lightning speed, but in reality, we often face bugs, output errors, or other various problems. Some useful skills to learn include: Fully understanding errors (not always easy) Knowing how and where to find a solution (even harder) If you can’t find a solution directly, asking for help effectively Abbiamo tutti le immagini in testa di programmatori da film che scrivono codice alla velocità della luce, quando nella realtà dobbiamo spesso affrontare bug, errori di output o altri problemi vari. Una serie di skills utili da imparare sono: Understanding Errors Carefully reading error messages is very important. R is usually quite explicit in explaining the problem. For example, using a function from a package that hasn’t been loaded will usually produce an error message like Error in function : could not find function “function”. Leggere con attenzione i messaggi di errore è molto importante. R è solitamente abbastanza esplicito nel farci capire il problema. Ad esempio usare una funzione di un pacchetto che non è stato caricato di solito fornisce un messaggio del tipo Error in my_function : could not find function \"my_function\". However, in other situations, the messages might not be as clear. While explicit, R is also very concise, and the use of very specific language (which may be unfamiliar at first) can make it hard to understand their meaning or even render them completely incomprehensible. As you become more experienced with R, understanding the problem and how to resolve it will become easier and quicker. But when you don’t know the solution, you’ll need to find it another way. Problem + Google (or chatGPT) = Solution In almost any situation, Google and chatGPT will be your best friends. By searching for the error/warning message on Google, 99% of the time, you will find other people who had the same problem and probably a solution as well. The best way to search is to copy and paste the R error message directly into Google, for example, Error in my_function : could not find function \"my_function\" rather than describing the problem in words. Error messages are standard for everyone, but your description is not. When searching this way, you will see that many results will directly address your error: Recent models of chatGPT, including those with free access, have become quite proficient in basic programming skills. They know virtually all base R code and most common R packages. So, if you don’t know how to solve a problem, try ask chatGPT to help you fixing the code you previously wrote, or even writing some R code from scratch: it will probably perform fairly well! Asking for a Solution to Human Users If your problem isn’t an error message but a specific use of R, the best approach is to search for something like: topic + brief description of the problem + R. In the following sections, you’ll see other aspects of programming in detail, but if you want to calculate the mean in R, you could write compute mean in R. Always search in English because the chances of finding a solution are much higher. After some searching, you’ll notice that the site you’ll see most often is called Stack Overflow. This is a godsend for all programmers, at any level of expertise. It’s a community where, through questions and answers, you can learn to solve various problems and even find new ways to do the same thing. It’s really useful and also a great way to learn. The last point in this small guide to finding solutions is not just about searching but also about asking. After browsing through various posts from people asking for help, you’ll notice that questions and answers always follow a similar structure. This is not just for style but is very useful for making the question and the answer clear, in the spirit of sharing. There’s also a dedicated guide on how to write the perfect question. In general1: Title: a concise summary of the problem Context: language (e.g., R), which operating system (e.g., Windows) Problem/Request Description: clear and simple but not too generic Code and any data to understand the problem The last point on this list is perhaps the most important and is called in technical jargon REPREX (Reproducible Example). It’s a slightly more advanced topic, but the basic idea is to provide all the necessary information to reproduce (and thus possibly solve) someone else’s code on your computer. If I say “R won’t let me create a new object, what’s the error?” it’s different from saying “the command object -&gt; 10 gives me this error Error in 10 &lt;- object : invalid (do_set) left-hand side to assignment, how can I fix it?” There are also several R packages that make creating these reproducible code examples automatic, such as the reprex package. Source: Writing the perfect question - Jon Skeet↩︎ "],["second-section.html", "Section 2 - Data Structures", " Section 2 - Data Structures In this section, the main types of objects used in R will be introduced. Specifically, the main structures in which data can be organized: Vectors, Matrices, Data Frames, and Lists. For each of them, we will describe their characteristics and see how to create, modify, and manipulate them as needed. The chapters are organized as follows: Chapter 7 - Vectors. We will learn the characteristics and use of vectors, also focusing on the different data types. Chapter 8 - Factors. We will learn the characteristics and use of factors, which are a specific type of vector used for categorical and ordinal variables. Chapter 9 - Matrices. We will learn the characteristics and use of matrices, also introducing arrays. Chapter 10 - Data Frames. We will learn the characteristics and use of data frames, the most commonly used object in data analysis. Chapter 11 - Lists. We will learn the characteristics and use of lists. "],["vector.html", "Chapter7 Vectors 7.1 Creation 7.2 Selecting Elements 7.3 Functions and Operations 7.4 Data Types", " Chapter7 Vectors Vectors are the simplest data structure in R. A vector is simply a collection of elements arranged in a specific order, and we can imagine it similarly to the representation shown in Figure 7.1. Figure 7.1: Representation of the structure of a vector of length n Two important characteristics of a vector are: la Length - the number of elements that make up the vector. la Type - the type of data that makes up the vector. A vector must be composed of elements all of the same type; therefore, there are different types of vectors depending on the data type (numeric, integer, logical, or character values). It’s also important to emphasize that each element of a vector is characterized by: un a value - the value of the element, which can be anything, such as a number or a string of characters. un a position index - a positive integer that identifies its position within the vector. Thus, vectors \\(x\\) and \\(y\\) defined as: \\[ x = [1, 3, 5];\\ \\ \\ y = [3, 1, 5], \\] though containing the same elements, are not identical because they differ in their order. This illustrates how the order of elements is crucial in evaluating a vector. Now, let’s see how to create vectors in R and perform common operations such as selection and manipulation. We will then explore vector characteristics by examining their different types. 7.1 Creation We’ve already encountered vectors in previous chapters, as even variables with a single value are simply vectors of length 1. However, to create vectors with multiple elements, we use the c() command, meaning “combine”, specifying the elements in the desired order and separating them with commas. The syntax is as follows: vector_name = c(x_1, x_2, x_3, ..., x_n) Note that the elements of a vector must all be of the same type, for example, numeric or character values. Alternatively, any function that returns a sequence of values as a vector can be used. Some of the most commonly used functions for creating sequences are: &lt;from&gt;:&lt;to&gt; - Generates a sequence of increasing (or decreasing) numeric values from (&lt;from&gt;) to (&lt;to&gt;) in steps of 1 (o -1 ). # increasing sequence 1:5 ## [1] 1 2 3 4 5 # decreasing sequence 2:-2 ## [1] 2 1 0 -1 -2 # sequence with decimal values 5.3:10 ## [1] 5.3 6.3 7.3 8.3 9.3 seq(from = , to = , by = , length.out = ) - Generates a regular sequence of numeric values between from and to with increments specified by by, or with a total length specified by length.out (see ?seq() for more details). # sequence with increments of 2 seq(from = 0, to = 10, by = 2) ## [1] 0 2 4 6 8 10 # sequence with 5 elements seq(from = 0, to = 1, length.out = 5) ## [1] 0.00 0.25 0.50 0.75 1.00 rep(x, times = , each = ) - Generates a sequence by repeating the values in x. The values in x can be repeated multiple times in order using times or each value can be repeated multiple times using each (see ?rep() for more details). # repeated sequence rep(c(&quot;foo&quot;, &quot;bar&quot;), times = 3) ## [1] &quot;foo&quot; &quot;bar&quot; &quot;foo&quot; &quot;bar&quot; &quot;foo&quot; &quot;bar&quot; # sequence with repeated elements rep(1:3, each = 2) ## [1] 1 1 2 2 3 3 Exercises Familiarize yourself with vector creation (solutions): Create the vector x containing the numbers 4, 6, 12, 34, 8. Create the vector y containing all the even numbers between 1 and 25 (?seq()). Create the vector z containing the first 10 multiples of 7 starting from 13 (?seq()). Create the vector s where the letters \"A\", \"B\", and \"C\" are repeated in the same order 4 times (?rep()). Create the vector t where the letters \"A\", \"B\", and \"C\" are each repeated 4 times (?rep()). Generate the following output with minimal code. ## [1] &quot;foo&quot; &quot;foo&quot; &quot;bar&quot; &quot;bar&quot; &quot;foo&quot; &quot;foo&quot; &quot;bar&quot; &quot;bar&quot; 7.2 Selecting Elements Once a vector is created, you may need to select one or more of its elements. In R, to select elements from a vector, square brackets [] are used after the vector name, with the position index of the desired elements inside the brackets: vector_name[&lt;position-index&gt;] Be careful not to specify the value of the desired element, but its position index. For example: # given the vector my_numbers = c(2,4,6,8) # to select the value 4, use its position index, which is 2 my_numbers[2] ## [1] 4 # If you use its value (4), # you&#39;ll get the element in the 4th position my_numbers[4] ## [1] 8 To select multiple elements, list all the desired position indices within the square brackets. Note that you can’t simply provide individual numbers; they must be enclosed in a vector, for example, using the c() function. Essentially, you use a vector of indices to select the elements from the original vector. # INCORRECT selection of multiple values my_numbers[1,2,3] ## Error in my_numbers[1, 2, 3]: incorrect number of dimensions # CORRECT selection of multiple values my_numbers[c(1,2,3)] ## [1] 2 4 6 my_numbers[1:3] ## [1] 2 4 6 Note that selecting elements does not modify the original vector. If you want to keep the changes, you need to save the result of the selection. my_words = c(&quot;foo&quot;, &quot;bar&quot;, &quot;baz&quot;, &quot;qux&quot;) # Selecting the first two elements my_words[1:2] ## [1] &quot;foo&quot; &quot;bar&quot; # The original vector still has all the elements my_words ## [1] &quot;foo&quot; &quot;bar&quot; &quot;baz&quot; &quot;qux&quot; # Save the result my_words = my_words[1:2] my_words ## [1] &quot;foo&quot; &quot;bar&quot; What happens if you use a position index greater than the number of elements in your vector? # My vector my_numbers = c(2,4,6,8) my_numbers[10] ## [1] NA R doesn’t return an error but gives the value NA (Not Available) to indicate that no value is available. Let’s also explore other special behaviors or possible errors in element selection: The position index must be a numeric value, not a character. # INCORRECT selection of multiple values my_numbers[&quot;3&quot;] ## [1] NA # CORRECT selection of multiple values my_numbers[3] ## [1] 6 Decimal numbers are ignored, not rounded. my_numbers[2.2] ## [1] 4 my_numbers[2.8] ## [1] 4 Using the value 0 returns an empty vector. my_numbers[0] ## numeric(0) 7.2.1 Advanced Uses of Selection Let’s now look at some advanced uses of vector element selection. Specifically, we will learn how to: use relational and logical operators to select elements from a vector change the order of elements create new combinations replace elements remove elements Relational and Logical Operators A useful function is selecting elements from a vector that meet a certain condition. To do this, you specify the condition inside square brackets using relational and logical operators (see Chapter 3.2). For example, we can select all elements greater than a certain value from a numeric vector, or select all elements equal to a specific string from a character vector. # Numeric vector - select elements greater than 0 my_numbers = -5:5 my_numbers[my_numbers &gt;= 0] ## [1] 0 1 2 3 4 5 # Character vector - select elements equal to &quot;bar&quot; my_words = rep(c(&quot;foo&quot;, &quot;bar&quot;), times = 4) my_words[my_words == &quot;bar&quot;] ## [1] &quot;bar&quot; &quot;bar&quot; &quot;bar&quot; &quot;bar&quot; To better understand this process, it’s important to note that there are two distinct steps in the same command: Logical vector (see Chapter 7.4.4) - When a vector is evaluated in a condition, R returns a new vector containing the answer (TRUE or FALSE) for each element of the original vector. Selection - We use the resulting logical vector to select elements from the original vector. Elements associated with TRUE are selected, while those associated with FALSE are discarded. We can make these two steps explicit in the following code: # Logical vector condition = my_words==&quot;bar&quot; condition ## [1] FALSE TRUE FALSE TRUE FALSE TRUE FALSE TRUE # Selection my_words[condition] ## [1] &quot;bar&quot; &quot;bar&quot; &quot;bar&quot; &quot;bar&quot; Sorting Elements Position indices can be used to sort the elements of a vector according to your needs. messy_vector = c(5,1,7,3) # Reorder the elements messy_vector[c(4,2,3,1)] ## [1] 3 1 7 5 # Sort elements in ascending order messy_vector[c(2,4,1,3)] ## [1] 1 3 5 7 To sort elements in ascending or descending order (either alphabetically or numerically), you can use the sort() function, specifying the decreasing argument. See the help page of the function for more information (?sort()). # Alphabetical order my_letters = c(&quot;cb&quot;, &quot;bc&quot;, &quot;ab&quot;, &quot;ba&quot;, &quot;cb&quot;, &quot;ab&quot;) sort(my_letters) ## [1] &quot;ab&quot; &quot;ab&quot; &quot;ba&quot; &quot;bc&quot; &quot;cb&quot; &quot;cb&quot; # Descending order sort(messy_vector, decreasing = TRUE) ## [1] 7 5 3 1 Note that there is also the order() function, but it is a false-friend because it does not directly provide a vector with sorted elements but instead returns the position indices for reordering the elements (?order()). See how to use this function in the following example: # Position indices for reordering elements order(messy_vector) ## [1] 2 4 1 3 # Reorder the vector using the position indices messy_vector[order(messy_vector)] ## [1] 1 3 5 7 Combinations of Elements The same position indices can be used multiple times to repeat elements in the desired combinations, forming a new vector. my_numbers = c(5,6,7,8) # Obtain a new vector with the desired combination my_numbers[c(1,2,2,3,3,3,4)] ## [1] 5 6 6 7 7 7 8 Replacing Elements An important use of indices is modifying an element in a vector. To replace an old value with a new one, you can use the assign function (&lt;- or =), as in the following example: my_names = c(&quot;Andrea&quot;, &quot;Bianca&quot;, &quot;Carlo&quot;) # Replace the name &quot;Bianca&quot; with &quot;Beatrice&quot; my_names[2] = &quot;Beatrice&quot; my_names ## [1] &quot;Andrea&quot; &quot;Beatrice&quot; &quot;Carlo&quot; To replace a value, you specify the value to modify on the left of the assignment operator, and the new value on the right. Note that this operation can also be used to add new elements to the vector. my_names[4] ## [1] NA # Add the name &quot;Daniela&quot; my_names[4] = &quot;Daniela&quot; my_names ## [1] &quot;Andrea&quot; &quot;Beatrice&quot; &quot;Carlo&quot; &quot;Daniela&quot; Removing Elements To remove elements from a vector, specify the position indices of the elements to remove inside square brackets, preceded by the - (minus) operator. If removing multiple elements, you can use the minus operator only before the c() function, for example, x[c(-2,-4)] becomes x[-c(2,4)]. my_words = c(&quot;foo&quot;, &quot;bar&quot;, &quot;baz&quot;, &quot;qux&quot;) # Remove &quot;bar&quot; my_words[-2] ## [1] &quot;foo&quot; &quot;baz&quot; &quot;qux&quot; # Remove &quot;foo&quot; and &quot;baz&quot; my_words[-c(1,3)] # alternatively, my_words[c(-1, -3)] ## [1] &quot;bar&quot; &quot;qux&quot; Note that removing elements is still a selection operation. Therefore, you need to save the result if you want to keep the changes. # Remove &quot;foo&quot; and &quot;baz&quot; my_words[-c(1,3)] ## [1] &quot;bar&quot; &quot;qux&quot; # The original vector still has all elements my_words ## [1] &quot;foo&quot; &quot;bar&quot; &quot;baz&quot; &quot;qux&quot; # Save the results my_words = my_words[-c(1,3)] my_words ## [1] &quot;bar&quot; &quot;qux&quot; 7.2.1.1 which() The which() function is very useful for obtaining the position within a vector that meets a certain logical condition. For instance, if we want to know the positions of values greater than 5 in a numeric vector, we can use the function which(x &gt; 5), where x is our numeric vector. ## [1] FALSE TRUE FALSE TRUE FALSE TRUE TRUE FALSE FALSE TRUE ## [1] 2 4 6 7 10 As you can see, the which() function essentially returns the position (not the value) where the tested condition is TRUE. It’s important to note that these two pieces of code are equivalent: ## [1] 8.041613 7.355383 10.277275 8.984358 9.572678 ## [1] 8.041613 7.355383 10.277275 8.984358 9.572678 In fact, as we’ve seen, you can index a vector with another vector indicating the position of elements to extract, or with a logical vector of the same length as the original vector. Exercises Complete the following exercises (solutions): Select the 2nd, 3rd, and 5th elements of the vector x. Select the values 34 and 4 from the vector x. Given the vector my_vector = c(2,4,6,8), comment on the result of the command my_vector[my_vector]. Select all values less than 13 or greater than 19 from the vector y. Select all values between 24 and 50 from the vector z. Select all elements equal to “A” from the vector s. Select all elements not equal to “B” from the vector t. Create a new vector u identical to s but where \"A\" is replaced with \"U\". Remove the values 28 and 42 from the vector z. 7.3 Functions and Operations Let’s now look at some useful functions and common operations that can be performed on vectors (see Table 7.1). Table 7.1: Table 7.2: Vector functions and operations Function Description new_vector = c(vector1, vector2) Combine multiple vectors into one vector length(new_vector) Evaluate the number of elements in a vector vector1 + vector2 Sum of two vectors vector1 - vector2 Difference between two vectors vector1 * vector2 Product of two vectors vector1 / vector2 Division of two vectors Note that mathematical operations (e.g., +, -, *, /) can be performed either on a single value or between two vectors: Single value - The operation will be applied to each element of the vector relative to the single value. Another vector - The operation will be applied to each pair of elements from both vectors. Therefore, the two vectors must have the same length, meaning the same number of elements. x = 1:5 y = 1:5 # Add a single value x + 10 ## [1] 11 12 13 14 15 # Sum of vectors (element-wise) x + y ## [1] 2 4 6 8 10 If the vectors have different lengths, R will issue a warning, alerting you to the issue, but it will still execute the operation by recycling the shorter vector. x + c(1, 2) ## Warning in x + c(1, 2): longer object length is not a multiple of shorter ## object length ## [1] 2 4 4 6 6 However, performing operations between vectors of different lengths (even if they are multiples) should be avoided, as it is prone to errors and misunderstandings. In R, most operators are vectorized, meaning they compute the result directly for each element in the vector. This is a significant advantage, as it allows us to write efficient and concise code. Without vectorization, each operation between two vectors would require specifying the operation for each element of the vector. In the previous example of adding x and y, we would have needed the following code: z = numeric(length(x)) for(i in seq_along(x)) { z[i] = x[i] + y[i] } z ## [1] 2 4 6 8 10 This also applies to relational and logical operators. When evaluating a condition on a vector, you get a response for each element of the vector. my_values = 1:8 # Values between 4 and 7 my_values &gt;= 4 &amp; my_values &lt;= 7 ## [1] FALSE FALSE FALSE TRUE TRUE TRUE TRUE FALSE Exercises Complete the following exercises (solutions): Create the vector j by combining the vectors x and z. Remove the last three elements of the vector j and check that the vectors j and y have the same length. Compute the sum of vectors j and y. Multiply the vector z by a constant k=3. Calculate the product of the first 10 elements of vector y with vector z. 7.4 Data Types We have seen that all elements in a vector must be of the same type. Therefore, there are different types of vectors depending on the type of data they contain. In R, we have 4 main data types, i.e., types of values that can be used: character - Character strings whose alphanumeric values are enclosed in double quotes \"Hello world!\" or single quotes 'Hello world!'. double - Real numbers with or without decimal places, such as 27 or 93.46. integer - Integer values defined by appending the letter L to the desired number, for example, 58L. logical - Valori logici TRUE and FALSE, used in logical operations. We can check the type of a value using the typeof() function. typeof(&quot;foo&quot;) ## [1] &quot;character&quot; typeof(2021) ## [1] &quot;double&quot; typeof(2021L) # Note the letter L ## [1] &quot;integer&quot; typeof(TRUE) ## [1] &quot;logical&quot; There are many other data types, such as complex (used to represent complex numbers of the form \\(x + yi\\)) and Raw (used to represent values as bytes), but these are less common or advanced uses in R and will not be covered. This distinction between different data types arises from how the computer internally represents various values. We know that a computer only has bits, i.e., sequences of 0s and 1s, such as 01000011. Without going into detail, to optimize memory usage, different values are mapped using bits differently depending on the data type. Therefore, in R, the value 24 will be represented differently depending on whether it is defined as a character string (\"24\"), an integer (24L), or a double (24). Integer vs Double One counterintuitive aspect is the difference between double and integer values. While integers can be represented precisely by a computer, not all real values can be represented exactly within the maximum number of 64 bits. In such cases, their values are approximated, and although this is done very accurately, it can sometimes lead to unexpected results. For example, in the following case, we don’t get zero, but we observe a small error due to the approximation of double values. my_value = sqrt(2)^2 # Should return 2 my_value - 2 # Should return 0 ## [1] 4.440892e-16 It is important to keep this issue in mind when performing equality tests, where using the == operator may produce unexpected answers. In general, the all.equal() function is preferred, which allows for some tolerance (see ?all.equal() for more details). my_value == 2 # Approximation issue ## [1] FALSE all.equal(my_value, 2) # Test with tolerance ## [1] TRUE Remember that computers also have limits concerning the maximum and minimum values they can represent, both for integer and real numbers. For more information, see https://stat.ethz.ch/pipermail/r-help/2012-January/300250.html. Let’s now look at the different types of vectors according to the type of data they use. 7.4.1 Character Vectors composed of character strings are defined as character vectors. To evaluate the type of an object, we can use the class() function, while the typeof() function evaluates the data type. In this case, both return character. my_words = c(&quot;Foo&quot;,&quot;Bar&quot;,&quot;foo&quot;,&quot;bar&quot;) class(my_words) # Object type ## [1] &quot;character&quot; typeof(my_words) # Data type ## [1] &quot;character&quot; It is not possible to perform arithmetic operations on character vectors, but we can evaluate equality or inequality relationships with another string. my_words + &quot;foo&quot; ## Error in my_words + &quot;foo&quot;: non-numeric argument to binary operator my_words == &quot;foo&quot; ## [1] FALSE FALSE TRUE FALSE 7.4.2 Numeric In R, unless otherwise specified, every numeric value is represented as a double, whether or not it has decimal places. Vectors made of double values are called numeric vectors. In R, the type of the vector is labeled as numeric, while the data is double. my_values = c(1,2,3,4,5) class(my_values) # Object type ## [1] &quot;numeric&quot; typeof(my_values) # Data type ## [1] &quot;double&quot; Numeric vectors are used to perform any kind of mathematical or logical-relational operations. my_values + 10 ## [1] 11 12 13 14 15 my_values &lt;= 3 ## [1] TRUE TRUE TRUE FALSE FALSE 7.4.3 Integer In R, to specify that a value is an integer, the letter L is added immediately after the number. Vectors made up of integer values are defined as integer vectors. In R, the type of the vector is labeled as integer, the same as the data. my_integers = c(1L,2L,3L,4L,5L) class(my_integers) # Object type ## [1] &quot;integer&quot; typeof(my_integers) # Data type ## [1] &quot;integer&quot; As with numeric vectors, integer vectors can be used to perform any kind of mathematical or logical-relational operations. However, note that operations between integers and doubles will return doubles, and even in the case of operations between integers, the result may not be an integer. is.integer(5L * 5) # Integer and double ## [1] FALSE is.integer(5L * 5L) # Integer and integer ## [1] TRUE is.integer(5L / 5L) # Integer and integer ## [1] FALSE 7.4.4 Logical Vectors made of logical values (TRUE and FALSE) are defined as logical vectors. In R, the type of the vector is labeled as logical, the same as the data. my_logical = c(TRUE, FALSE, TRUE) class(my_logical) # Object type ## [1] &quot;logical&quot; typeof(my_logical) # Data type ## [1] &quot;logical&quot; Logical vectors can be used with logical operators. my_logical &amp; c(FALSE, TRUE, TRUE) ## [1] FALSE FALSE TRUE my_logical &amp; c(0, 1, 3) ## [1] FALSE FALSE TRUE Remember that TRUE and FALSE are associated with the numeric values 1 and 0, respectively (more precisely, the integer values 1L and 0L). Therefore, it is possible to perform mathematical operations where they will be automatically considered their respective numeric values. Obviously, the result will be a numeric value, not a logical one. TRUE * 10 ## [1] 10 FALSE * 10 ## [1] 0 Using the sum() and mean() functions with a logical vector, we can evaluate the total number and percentage of elements that satisfy a certain logical condition. my_values = rnorm(50) # Generate random numbers sum(my_values &gt; 0) # Total number of positive numbers ## [1] 32 mean(my_values &gt; 0) # Percentage of positive numbers ## [1] 0.64 There are two families of functions that allow you to test and modify the data type. is.* Family To test if a certain value (or a vector of values) belongs to a specific data type, we can use one of the following functions: is.vector() - checks if an object is a generic vector of any type. is.vector(&quot;2021&quot;) # TRUE is.vector(2021) # TRUE is.vector(2021L) # TRUE is.vector(TRUE) # TRUE is.character() - checks if the object is a string. is.character(&quot;2021&quot;) # TRUE is.character(2021) # FALSE is.character(2021L) # FALSE is.character(TRUE) # FALSE is.numeric() - checks if the object is a numeric value, whether it is a double or an integer. is.numeric(&quot;2021&quot;) # FALSE is.numeric(2021) # TRUE is.numeric(2021L) # TRUE is.numeric(TRUE) # FALSE is.double() - checks if the object is a double value. is.double(&quot;2021&quot;) # FALSE is.double(2021) # TRUE is.double(2021L) # FALSE is.double(TRUE) # FALSE is.integer() - checks if the object is an integer value. is.integer(&quot;2021&quot;) # FALSE is.integer(2021) # FALSE is.integer(2021L) # TRUE is.integer(TRUE) # FALSE is.logical() - checks if the object is a logical value. is.logical(&quot;2021&quot;) # FALSE is.logical(2021) # FALSE is.logical(2021L) # FALSE is.logical(TRUE) # TRUE as.* Family To modify the data type of a certain value (or a vector of values), we can use one of the following functions: as.character() - transforms the object into a string. as.character(2021) ## [1] &quot;2021&quot; as.character(2021L) ## [1] &quot;2021&quot; as.character(TRUE) ## [1] &quot;TRUE&quot; as.numeric() - transforms the object into a double as.numeric(&quot;foo&quot;) # Invalid for character strings ## Warning: NAs introduced by coercion ## [1] NA as.numeric(&quot;2021&quot;) # Valid for numeric strings ## [1] 2021 as.numeric(2021L) ## [1] 2021 as.numeric(TRUE) ## [1] 1 as.double() - transforms the object into a double as.double(&quot;2021&quot;) # Valid for numeric strings ## [1] 2021 as.double(2021L) ## [1] 2021 as.double(TRUE) ## [1] 1 as.integer() - transforms the object into an integer as.integer(&quot;2021&quot;) # Valid for numeric strings ## [1] 2021 as.integer(2021.6) # Truncates the decimal part ## [1] 2021 as.integer(TRUE) ## [1] 1 as.logical() - transforms a numeric object into a logical value, with any non-zero value considered TRUE as.logical(&quot;2021&quot;) # Invalid for strings ## [1] NA as.logical(0) ## [1] FALSE as.logical(0.5) ## [1] TRUE as.logical(2021L) ## [1] TRUE 7.4.5 Special Values Let’s now look at some special values used in R, which have specific meanings and require particular care when handled: NULL- represents the null object, meaning the absence of an object. It is often returned by functions when their output is undefined. NA - represents missing data (Not Available). It is a constant value of length 1 that can be used for any data type. NaN - indicates a mathematical result that cannot be represented as a numeric value (Not A Number). It is a constant value of length 1 that can be used as a numeric (non-integer) value. 0/0 ## [1] NaN sqrt(-1) ## Warning in sqrt(-1): NaNs produced ## [1] NaN Inf (or -Inf) - indicates an infinite (or negative infinite) mathematical result. It is also used to represent extremely large numbers. pi^650 ## [1] Inf -pi/0 ## [1] -Inf It is important to be aware of the characteristics of these values, as they can exhibit peculiar behaviors, which, if not properly managed, can lead to errors in the code. Let’s now describe some of their most important characteristics. Element Length First, note that while NULL is effectively a null object with no dimension, NA is a special value that represents the presence of missing data. Therefore, unlike NULL, NA is a value of length 1. # The value NULL is a null object values_NULL = c(1:5, NULL) length(values_NULL) ## [1] 5 values_NULL # NULL is not present ## [1] 1 2 3 4 5 # The value NA is an object that represents an absence values_NA = c(1:5, NA) length(values_NA) ## [1] 6 values_NA # NA is present ## [1] 1 2 3 4 5 NA Similarly, both NaN and Inf are values of length 1, used to indicate special numeric results. length(c(1:5, NaN)) ## [1] 6 length(c(1:5, Inf)) ## [1] 6 Value Propagation Another important characteristic is the propagation of these special values. Operations that involve these special values will return the same special value. This means that these values will propagate from result to result in the code unless properly handled. NULL - If NULL is used in any mathematical operation, the result will be an empty numeric vector of dimension 0, which can be interpreted similarly (though not identically) to the value NULL. res_NULL = NULL * 3 length(res_NULL) ## [1] 0 res_NULL ## numeric(0) NA - When NA is used in any mathematical operation, the result will again be NA. NA * 3 ## [1] NA NaN - Similarly, when NaN is used in any mathematical operation, the result will again be NaN. NaN * 3 ## [1] NaN Inf (or -Inf) - If Inf (or -Inf) is used in a mathematical operation, the result will follow the common rules of operations involving infinity. Inf - 3 # Inf Inf * -3 # - Inf Inf + Inf # Inf Inf + -Inf # NaN Inf * -Inf # -Inf Inf / Inf # NaN Testing for Values It is important to remember that to test the presence of one of these special values, there are specific functions in the is.* family. You should never use the common equality operator ==, as it does not provide the correct results. is.null NULL == NULL # logical(0) is.null(NULL) # TRUE is.na NA == NA # NA is.na(NA) # TRUE is.nan NaN == NaN # NA is.nan(NaN) # TRUE Inf Inf == Inf # TRUE (sign is also considered) is.infinite(Inf) # TRUE for both Inf and -Inf Logical Operators A particular behavior involves the results obtained with logical operators, where the propagation of the value does not always follow expectations. Let’s look at different cases: NULL- as expected, we obtain an empty logical vector of dimension 0. TRUE &amp; NULL # logical(0) TRUE | NULL # logical(0) FALSE &amp; NULL # logical(0) FALSE | NULL # logical(0) NA - we do not always obtain NA as expected, but in some conditions, the result will be TRUE or FALSE. TRUE &amp; NA # NA TRUE | NA # TRUE FALSE &amp; NA # FALSE FALSE | NA # NA NaN - we obtain the same results as in the previous case when using the value NA TRUE &amp; NaN # NA TRUE | NaN # TRUE FALSE &amp; NaN # FALSE FALSE | NaN # NA Inf - since it is a non-zero numeric value, we obtain the expected results. TRUE &amp; Inf # TRUE TRUE | Inf # TRUE FALSE &amp; Inf # FALSE FALSE | Inf # TRUE The strange behavior regarding the use of the value NA with logical operators can be explained by the fact that NA is actually a logical value that indicates a missing response. is.logical(NA) ## [1] TRUE Thus, the propositions are evaluated according to common rules. In the case of TRUE | NA, the proposition is considered TRUE because, with the OR operator, it is sufficient for one of the parts to be true for the proposition to be true. In the case of FALSE &amp; NA, the proposition is considered FALSE because, with the AND operator, it is sufficient for one of the parts to be false for the proposition to be false. The lack of response indicated by NA is irrelevant in these cases but determines the result in the remaining cases, where both parts of the proposition must be evaluated. In such cases, the operators return NA, as they are unable to determine the response. As for the case of the NaN value, it is enough to remember that it is still a numeric value, although its exact value cannot be determined. is.numeric(NaN) ## [1] TRUE All numeric values are considered valid in logical operations, where any non-zero number is evaluated as TRUE. Therefore, the same reasoning applies: when it is not necessary to evaluate both parts of the proposition, a result is provided; when both parts must be evaluated, NA is returned, as R cannot determine the value of NaN. Working with missing data will happen in most cases. Many functions in R already have options to automatically remove any missing data, so that correct results can be obtained. my_sample = c(2,4,6,8, NA) mean(my_sample) ## [1] NA mean(my_sample, na.rm = TRUE) ## [1] 5 However, it is important not to rely automatically on these options but to carefully evaluate the presence of missing data. This allows us to investigate potential patterns related to missing data and assess their possible influence on our results and the validity of our conclusions. Furthermore, it will be essential to always check the actual sample size used in various analyses. For example, if not carefully considered, we may not get the actual number of values used to compute the mean. length(my_sample) # NA included ## [1] 5 length(my_sample[!is.na(my_sample)]) # NA excluded ## [1] 4 "],["factor.html", "Chapter8 Factors 8.1 Object Attributes 8.2 Factors", " Chapter8 Factors In this chapter, we will look at factors, a special type of vector used to store information about a categorical variable (nominal or ordinal). However, before introducing factors, we will describe what attributes of an object are. This will allow us to better understand the functionality of factors later on. 8.1 Object Attributes In R, objects have what are called attributes, which are useful pieces of information about the object itself, a kind of metadata. These pieces of information do not interfere with the values contained in the objects nor are they normally shown in the output of an object. However, they are particularly useful in some circumstances and allow us to provide special information associated with a specific object. Objects have different attributes depending on their type. However, the most commonly used ones include: Class (class) - the class (or type) of an object. This allows us to verify the type of data structure for a particular object. Names (names) - names of the elements of an object. For example, it allows you to assign names to the elements of a vector or to the rows and columns of a matrix or dataframe. Dimension (dim) - the dimension of the object. This attribute is not available for vectors but will be particularly important in the case of matrices and dataframes. There are specific functions dedicated to evaluating and possibly modifying the attributes of an object. For example: attributes() - lists all the attributes of an object class() - accesses the class attribute of an object names() - accesses the names attribute of an object dim() - accesses the dim attribute of an object Let’s now see some uses of attributes with vectors. The attributes in the case of other object types will be addressed in their respective chapters. 8.1.1 Attributes of a Vector Let’s see how a generic vector initially does not have any attributes. my_vector = 1:10 attributes(my_vector) ## NULL Class By executing the class() function, however, we can still get the precise type of vector, in this case, \"integer\". class(my_vector) ## [1] &quot;integer&quot; Dimension As anticipated, the dim attribute is not available for vectors, though it will become very important in the case of matrices and dataframes. However, an analogous value for the size of a vector is given by its length, which is evaluated with the length() function. ## NULL ## [1] 10 Element Names Initially, the elements of a vector do not have names. names(my_vector) ## NULL To set the names of the elements, we need to assign a character vector to names(vector_name), containing the desired names, with the same length as the vector we are renaming. names(my_vector) = paste0(&quot;Item_&quot;, 1:10) my_vector ## Item_1 Item_2 Item_3 Item_4 Item_5 Item_6 Item_7 Item_8 Item_9 Item_10 ## 1 2 3 4 5 6 7 8 9 10 This process allows us to create what is called a named vector. We can see how the element names now appear among the object’s attributes. ## $names ## [1] &quot;Item_1&quot; &quot;Item_2&quot; &quot;Item_3&quot; &quot;Item_4&quot; &quot;Item_5&quot; &quot;Item_6&quot; &quot;Item_7&quot; ## [8] &quot;Item_8&quot; &quot;Item_9&quot; &quot;Item_10&quot; A particular use of named vectors is selecting values by their element names. Note that for this to work correctly, all elements must have different names. my_vector[c(&quot;Item_3&quot;, &quot;Item_5&quot;)] ## Item_3 Item_5 ## 3 5 In the case of vectors, this approach is rarely used, but we will see that it becomes very common for selecting variables in a dataframe. 8.2 Factors Factors are a special type of vector that, through the use of attributes, allow for the efficient storage of categorical variables (nominal or ordinal). The command used to create a factor in R is factor() and contains several arguments: factor_name = factor(x, levels = , ordered = FALSE) x - the data for our categorical variable levels- the possible levels of our categorical variable ordered - logical value indicating whether it is a nominal (FALSE) or ordinal (TRUE) For example, we could create the variable eye_color to record the eye color of members of a class: # Create the data my_values = rep(c(&quot;green&quot;, &quot;brown&quot;, &quot;blue&quot;), times = 3) my_values ## [1] &quot;green&quot; &quot;brown&quot; &quot;blue&quot; &quot;green&quot; &quot;brown&quot; &quot;blue&quot; &quot;green&quot; &quot;brown&quot; &quot;blue&quot; # Create the factor my_factor = factor(my_values) my_factor ## [1] green brown blue green brown blue green brown blue ## Levels: blue brown green Note that it is not necessary to specify the levels argument. The levels of the variable are automatically determined from the data present and ordered alphabetically. However, specifying the levels when creating a factor allows us to define the order of the levels and even include levels not present in the data. 8.2.1 Factor Structure Let’s now understand the structure of factors and the use of attributes. attributes(my_factor) ## $levels ## [1] &quot;blue&quot; &quot;brown&quot; &quot;green&quot; ## ## $class ## [1] &quot;factor&quot; We see that the class of the object is factor and that there is an additional levels attribute where the possible levels of our variable are stored. But now pay attention to what we get when we evaluate the data type contained in the factor and its structure. # Data type typeof(my_factor) ## [1] &quot;integer&quot; # Structure str(my_factor) ## Factor w/ 3 levels &quot;blue&quot;,&quot;brown&quot;,..: 3 2 1 3 2 1 3 2 1 We would have expected to get character, thinking that the factor stores the values of our variable as strings. Instead, the factor is made of integer values, and the output of the str() command reports numeric values (along with the variable levels). How do we explain this? The solution is simple. When creating a factor, R evaluates the levels present, creating the levels attribute, and then replaces each element with a numeric value that indicates the level of the variable. Therefore, in our example, the value 1 is associated with the level \"blue\", the value 2 with \"brown\", and the value 3 with \"green\". This approach optimizes memory usage but may initially seem unintuitive and can lead to errors. One of the main errors involves converting a factor back into a regular vector. If we want to get a vector of characters, we can use the as.character() function to get the desired result. as.character(my_factor) ## [1] &quot;green&quot; &quot;brown&quot; &quot;blue&quot; &quot;green&quot; &quot;brown&quot; &quot;blue&quot; &quot;green&quot; &quot;brown&quot; &quot;blue&quot; However, if we want to get a numeric vector, we need to be particularly careful. Consider the following example where we have the years of education of participants in a study. We might perform some analyses considering this variable as categorical and then convert it back to a numeric variable for further analysis. Watch what happens: # Create the variable as a factor school_years = factor(c(11, 8, 4, 8, 11, 4, 11, 8)) school_years ## [1] 11 8 4 8 11 4 11 8 ## Levels: 4 8 11 # Convert to a numeric vector as.numeric(school_years) ## [1] 3 2 1 2 3 1 3 2 Unexpectedly, we do not get the original values (i.e., 4, 8, 11) but different values. These are actually the numeric values R used to associate each element with its corresponding level. To get the correct values, we must use the following command: as.numeric(as.character(school_years)) ## [1] 11 8 4 8 11 4 11 8 This allows us to first replace the values with the correct labels, i.e., the levels of the variable, and then convert everything into a numeric vector. It’s important to be very careful in these cases because a potential error might not be immediately apparent. 8.2.2 Factor Operations Now that we understand how factors work, let’s look at some common operations. Renaming Levels It is possible to rename the levels of a factor using the levels() function, which allows us to access the current levels and possibly replace them. my_factor ## [1] green brown blue green brown blue green brown blue ## Levels: blue brown green # Current levels levels(my_factor) ## [1] &quot;blue&quot; &quot;brown&quot; &quot;green&quot; # Rename the levels (just replace with Italian color names) levels(my_factor) = c(&quot;blu&quot;, &quot;marrone&quot;, &quot;verde&quot;) my_factor ## [1] verde marrone blu verde marrone blu verde marrone blu ## Levels: blu marrone verde Reordering Levels It is important not to confuse reordering levels with renaming them. In the first case, only the order of the levels is modified, while in the second case, all the actual values of the elements would be changed. Generally, it is preferable to redefine the factor by specifying the levels argument. Let’s look at an example where we collect data regarding drug dosages: dosage = factor(rep(c(&quot;medium&quot;, &quot;low&quot;, &quot;high&quot;), times = 2)) dosage ## [1] medium low high medium low high ## Levels: high low medium Without specifying the levels argument, the levels are automatically defined in alphabetical order. Let’s see what happens if, by mistake, we rename the levels instead of correctly reordering them. # Create a copy dosage_wrong = dosage # ERROR: rename the levels levels(dosage_wrong) = c(&quot;low&quot;, &quot;medium&quot;, &quot;high&quot;) dosage_wrong ## [1] high medium low high medium low ## Levels: low medium high Note that this is a serious mistake because by renaming the levels, we have also changed the actual values of the elements. Now the values are all different and nonsensical. To correctly reorder the levels, we can reuse the factor() function, specifying the levels in the desired order. dosage = factor(dosage, levels = c(&quot;low&quot;, &quot;medium&quot;, &quot;high&quot;)) dosage ## [1] medium low high medium low high ## Levels: low medium high This way, we have reordered the levels as we wished without changing the actual values. Extra Several other operations are possible with factors. For instance, we might want to remove a certain level of a factor: if we make a subset of a factor and no longer have values associated with that level if we simply want to remove a level and the respective observations Let’s create a factor including a series of values in {\"a\", \"b\", \"c\"}; these values will also be automatically set as the levels by the factor function: # more compact version is: factor(rep(c(&quot;a&quot;,&quot;b&quot;,&quot;c&quot;),c(7,4,3))) my_factor = factor(c(&quot;a&quot;,&quot;a&quot;,&quot;a&quot;,&quot;a&quot;,&quot;a&quot;,&quot;a&quot;,&quot;a&quot;,&quot;b&quot;,&quot;b&quot;,&quot;b&quot;,&quot;b&quot;,&quot;c&quot;,&quot;c&quot;,&quot;c&quot;)) my_factor ## [1] a a a a a a a b b b b c c c ## Levels: a b c Now, let’s copy this factor into a new one, but retaining only the values \"a\" and \"b\". As you can see, even though there are no more \"c\" values, the factor still retains all the initial levels (including \"c\"), because they are part of the attributes that were copied from the original object: # Keep only the values &#39;a&#39; and &#39;b&#39; new_my_factor = my_factor[1:10] new_my_factor ## [1] a a a a a a a b b b ## Levels: a b c In these cases, we can use the droplevels(x, exclude = ...) function to remove certain levels. We can either specify the particular levels to be removed using the exclude argument, or even indicate no specific levels to be excluded. In the latter case, levels associated with no observations in the vector will automatically be excluded: # Explicitly indicate which levels should be removed droplevels(new_my_factor, exclude=&quot;c&quot;) ## [1] a a a a a a a b b b ## Levels: a b # Indicate no levels to be removed; it will automatically drop levels associated with no observations droplevels(new_my_factor) ## [1] a a a a a a a b b b ## Levels: a b If you use droplevels to forcibly remove a level that is associated with actual values in the vectors (such as \"a\"), the corresponding values will become NA: droplevels(new_my_factor, exclude = &quot;a&quot;) ## [1] &lt;NA&gt; &lt;NA&gt; &lt;NA&gt; &lt;NA&gt; &lt;NA&gt; &lt;NA&gt; &lt;NA&gt; b b b ## Levels: b Just as it is possible to remove a level, it is also possible to add a level to a factor simply by using the factor() command and specifying all the old levels plus the new one: factor(my_factor, levels = c(levels(my_factor), &quot;newlevel&quot;)) ## [1] a a a a a a a b b b b c c c ## Levels: a b c newlevel In this case, we used the c(old_levels, new_levels) function to create a vector of new levels to use, including all the previous levels plus the new one(s). Alternatively, we can also use the assignment method levels(x) = by specifying a vector of levels: # more compact version is: factor(rep(c(&quot;a&quot;,&quot;b&quot;,&quot;c&quot;),c(7,4,3))) my_factor = factor(c(&quot;a&quot;,&quot;a&quot;,&quot;a&quot;,&quot;a&quot;,&quot;a&quot;,&quot;a&quot;,&quot;a&quot;,&quot;b&quot;,&quot;b&quot;,&quot;b&quot;,&quot;b&quot;,&quot;c&quot;,&quot;c&quot;,&quot;c&quot;)) levels(my_factor) = c(&quot;a&quot;,&quot;b&quot;,&quot;c&quot;,&quot;newlevel&quot;) my_factor ## [1] a a a a a a a b b b b c c c ## Levels: a b c newlevel You can also combine two factors to obtain a single factor, merging the levels and their respective numeric values. Simply use the c(fac1, fac2) command: fac1 = factor(c(&quot;a&quot;,&quot;a&quot;,&quot;a&quot;,&quot;a&quot;,&quot;b&quot;,&quot;b&quot;,&quot;c&quot;)) fac2 = factor(c(&quot;d&quot;,&quot;d&quot;,&quot;d&quot;)) c(fac1, fac2) ## [1] a a a a b b c d d d ## Levels: a b c d 8.2.3 Ordinal Factors Finally, let’s look at an example of an ordinal categorical variable. Going back to the previous example regarding drug dosage, it’s clear that there is an ordinal relationship between the various levels of the variable. To create an ordinal variable, we can specify the ordered = TRUE argument: dosage_ord = factor(dosage, levels = c(&quot;low&quot;, &quot;medium&quot;, &quot;high&quot;), ordered = TRUE) dosage_ord ## [1] medium low high medium low high ## Levels: low &lt; medium &lt; high We notice that the ordinal nature of the levels is specified both when the levels are reported and in the object’s class. # Nominal categorical variable class(dosage) ## [1] &quot;factor&quot; # Ordinal categorical variable class(dosage_ord) ## [1] &quot;ordered&quot; &quot;factor&quot; In R, it’s important to correctly code different variables by specifying their type. By appropriately distinguishing categorical variables (nominal and ordinal) from numerical variables and simple character variables, we gain numerous advantages. In R, many packages and functions adopt specific behaviors depending on the variable type, providing us with outputs and results consistent with the nature of the variable. Note, for example, how the output of the summary() function changes depending on the variable type. # Numerical variable summary(1:15) ## Min. 1st Qu. Median Mean 3rd Qu. Max. ## 1.0 4.5 8.0 8.0 11.5 15.0 # Categorical variable summary(dosage) ## low medium high ## 2 2 2 This will be particularly important when performing statistical analyses and creating charts and tables. Exercises Complete the following exercises (solutions): 1.Create the categorical variable gender as defined below: ## [1] M F M F M F F F M ## Levels: F M Rename the levels of the genere variable to \"women\" and \"men\", respectively. Create the categorical variable treatment as defined below: ## [1] CBT Psychoanalysis CBT Psychoanalysis CBT ## [6] Psychoanalysis Control Control CBT ## Levels: CBT Control Psychoanalysis Correct the 7th and 8th observations in the treatment variable to Medication. Add the following new observations to the treatment variable: ## [1] &quot;Medication&quot; &quot;Control&quot; &quot;Medication&quot; "],["matrix.html", "Chapter9 Matrices 9.1 Creation 9.2 Element Selection 9.3 Functions and Operations 9.4 Arrays", " Chapter9 Matrices Matrices are a two-dimensional data structure, where elements are arranged in rows and columns. We can thus imagine a generic matrix with m rows and n columns similar to what is represented in Figure 9.1. Figure 9.1: Representation of the structure of a matrix with m columns and n rows Two important characteristics of a matrix are: dimension - the number of rows and columns that make up the matrix type - the type of data contained in the matrix. Indeed, similar to what we observed with vectors, a matrix must be formed by elements of the same type. Therefore, there are different types of matrices depending on the kind of data they contain, specifically numeric, logical, and character matrices (see Chapter 9.1.1). It is also crucial to emphasize that each element of a matrix is characterized by: a value - that is, the value of the element which can be of any type, such as a number or a series of characters. a position index - that is, a pair of values (i, j) positive integers that indicate respectively the row index and the column index, allowing us to uniquely identify the element within the matrix. For example, given a matrix \\(X\\) of size \\(3\\times4\\) (i.e., 3 rows and 4 columns) defined as: \\[ X = \\begin{bmatrix} 3 &amp; 12 &amp; 7 &amp; 20\\\\ 16 &amp; 5 &amp; 9 &amp; 13\\\\ 10 &amp; 1 &amp; 14 &amp; 19 \\end{bmatrix}, \\] we have \\(x_{2, 3} = 9\\) while \\(x_{3, 2} = 1\\). This serves to reinforce the correct use of indices, where for a generic element \\(x_{i, j}\\), the value i is the row index while j is the column index. Rows are indicated first, then columns. Now, let’s see how to create matrices in R and how to perform common selection operations. Later, we will examine various manipulations and operations with matrices. Finally, we will briefly extend the concept of matrices to dimensions greater than two through the use of arrays. 9.1 Creation The command used to create a matrix in R is matrix() and it includes several arguments: nome_matrice = matrix(data, nrow = , ncol = , byrow = FALSE) data - a vector of values used to populate the matrix nrow and ncol - are respectively the number of rows and the number of columns of the matrix byrow - indicates whether the matrix should be populated by row or by column. The default value is FALSE, so matrix values are added column by column. Indicate TRUE to add elements row by row. Let’s create a matrix with 3 rows and 4 columns with values from 1 to 12 as an example. # Data to populate the matrix my_values = 1:12 my_values ## [1] 1 2 3 4 5 6 7 8 9 10 11 12 # Matrix populated by columns mat_bycol = matrix(my_values, nrow = 3, ncol = 4) mat_bycol ## [,1] [,2] [,3] [,4] ## [1,] 1 4 7 10 ## [2,] 2 5 8 11 ## [3,] 3 6 9 12 The matrix() function has byrow = FALSE by default, so base R populates matrices column by column. To populate matrices row by row, you must explicitly request it by specifying byrow = TRUE. # Matrix populated by rows mat_byrow = matrix(my_values, nrow = 3, ncol = 4, byrow = TRUE) mat_byrow ## [,1] [,2] [,3] [,4] ## [1,] 1 2 3 4 ## [2,] 5 6 7 8 ## [3,] 9 10 11 12 It is important to note that while it is possible to specify any combination of rows and columns, the number of values provided to populate the matrix must be compatible with the dimensions of the matrix. In other words, I cannot provide more or fewer data than the matrix can hold. Thus, the length of the vector passed to the data argument must be compatible with the nrow and ncol arguments. However, it is possible to provide a single value if you want to obtain a matrix where all values are identical. For example, let’s create an empty matrix filled with NA values with 3 rows and 3 columns. mat_NA = matrix(NA, nrow = 3, ncol = 3) mat_NA ## [,1] [,2] [,3] ## [1,] NA NA NA ## [2,] NA NA NA ## [3,] NA NA NA In reality, it is possible to provide more or fewer data than the matrix can contain. If more values are provided, R simply uses the first available values, ignoring the subsequent ones. matrix(1:20, nrow = 2, ncol = 2) ## Warning in matrix(1:20, nrow = 2, ncol = 2): data length differs from size of ## matrix: [20 != 2 x 2] ## [,1] [,2] ## [1,] 1 3 ## [2,] 2 4 If fewer values are provided, R reuses the same values in the same order to fill the matrix, warning us of the problem. matrix(1:4, nrow = 3, ncol = 4) ## [,1] [,2] [,3] [,4] ## [1,] 1 4 3 2 ## [2,] 2 1 4 3 ## [3,] 3 2 1 4 However, it is best to avoid this practice of cycling values as the results may be unclear and it is easy to make mistakes. 9.1.1 Matrix types We have seen that, similar to vectors, for matrices it is also necessary that all data is of the same type. Therefore, we will have matrices that include only character, double, integer, or logical values, and the operations that can be performed (using mathematical operators or logical-relational operators) will depend on the type of data. However, unlike vectors, the object type will always remain matrix regardless of the data contained. Matrices are always matrices; it is the type of data that varies. Character It is possible to define a matrix of characters only, although they are rarely used since clearly all mathematical operations are not possible. mat_char = matrix(letters[1:12], nrow = 3, ncol = 4, byrow = TRUE) mat_char ## [,1] [,2] [,3] [,4] ## [1,] &quot;a&quot; &quot;b&quot; &quot;c&quot; &quot;d&quot; ## [2,] &quot;e&quot; &quot;f&quot; &quot;g&quot; &quot;h&quot; ## [3,] &quot;i&quot; &quot;j&quot; &quot;k&quot; &quot;l&quot; class(mat_char) ## [1] &quot;matrix&quot; &quot;array&quot; typeof(mat_char) ## [1] &quot;character&quot; In R, there are two special objects letters and LETTERS that include the lowercase and uppercase letters of the English alphabet, respectively. letters[1:5] ## [1] &quot;a&quot; &quot;b&quot; &quot;c&quot; &quot;d&quot; &quot;e&quot; LETTERS[6:10] ## [1] &quot;F&quot; &quot;G&quot; &quot;H&quot; &quot;I&quot; &quot;J&quot; Numeric Numeric value matrices, both double and integer, are undoubtedly the most common and widely used. They are often utilized to perform computationally efficient algebraic calculations. # doubles mat_num = matrix(5, nrow = 3, ncol = 4) class(mat_num) ## [1] &quot;matrix&quot; &quot;array&quot; typeof(mat_num) ## [1] &quot;double&quot; # integers mat_int = matrix(5L, nrow = 3, ncol = 4) class(mat_int) ## [1] &quot;matrix&quot; &quot;array&quot; typeof(mat_int) ## [1] &quot;integer&quot; Logical Finally, matrices can also be formed by logical values TRUE and FALSE. We will see an important use of these regarding the selection of elements from a matrix in Chapter 9.2.1. mat_logic = matrix(c(TRUE, FALSE), nrow = 3, ncol = 4) mat_logic ## [,1] [,2] [,3] [,4] ## [1,] TRUE FALSE TRUE FALSE ## [2,] FALSE TRUE FALSE TRUE ## [3,] TRUE FALSE TRUE FALSE class(mat_logic) ## [1] &quot;matrix&quot; &quot;array&quot; typeof(mat_logic) ## [1] &quot;logical&quot; Remember that it is still possible to perform mathematical operations with logical values as they will be automatically converted to their respective numerical values 1 and 0. Exercises Complete the following exercises (solutions): 1. Create the matrix A defined as: \\[ \\begin{matrix} 2 &amp; 34 &amp; 12 &amp; 7\\\\ 46 &amp; 93 &amp; 27 &amp; 99\\\\ 23 &amp; 38 &amp; 7 &amp; 04 \\end{matrix} \\] Create the matrix B containing the first 12 odd numbers arranged in 4 rows and 3 columns. Create the matrix C containing the first 12 multiples of 9 arranged in 3 rows and 4 columns. Create the matrix D formed by 3 columns where the letters \"A\", \"B\" and \"C\" are repeated 4 times each respectively in the first, second, and third columns. Create the matrix E formed by 3 rows where the letters \"A\", \"B\" and \"C\" are repeated 4 times each respectively in the first, second, and third rows. 9.2 Element Selection The most important (and fun) aspect of matrices is accessing the various elements. Remember that a matrix is simply a grid of rows and columns where various values are arranged. Regardless of what the matrix contains, you can use the row and column indices to uniquely identify a given element in the matrix. Therefore, each element is associated with a pair of values (i, j) where i is the row index and j is the column index. o illustrate this concept, the following example shows the indices for each element of a \\(3\\times4\\) matrix: ## [,1] [,2] [,3] [,4] ## [1,] &quot;1,1&quot; &quot;1,2&quot; &quot;1,3&quot; &quot;1,4&quot; ## [2,] &quot;2,1&quot; &quot;2,2&quot; &quot;2,3&quot; &quot;2,4&quot; ## [3,] &quot;3,1&quot; &quot;3,2&quot; &quot;3,3&quot; &quot;3,4&quot; In R, you can select an element of a matrix using its row and column index. Similar to vectors, you need to indicate within square brackets [ ] placed after the name of the matrix, the row index and column index, separated by a comma. nome_matrice[&lt;row-index&gt;, &lt;column-index&gt;] The order [&lt;row-index&gt;, &lt;column-index&gt;] is predetermined and must be respected for the selection to occur correctly. Let’s see a simple example of how it is possible to access any element: my_matrix = matrix(1:12, nrow = 3, ncol = 4) my_matrix ## [,1] [,2] [,3] [,4] ## [1,] 1 4 7 10 ## [2,] 2 5 8 11 ## [3,] 3 6 9 12 # Select the element at row 2 and column 3 my_matrix[2,3] ## [1] 8 # Select the value 6 my_matrix[3,2] ## [1] 6 Note how indicating indices outside the matrix dimension results in an error message. my_matrix[20,30] ## Error in my_matrix[20, 30]: subscript out of bounds In addition to selecting a single element, other types of selection are possible: Selecting a Row or Column You can select all elements of a row or a column using the following syntax: # Select entire row matrix_name[&lt;row-index&gt;, ] # Select entire column matrix_name[ , &lt;column-index&gt;] Note that the comma is necessary, leaving the position before or after the comma empty to indicate to R to select all rows or all columns, respectively. # Select row 2 and all columns my_matrix[2, ] ## [1] 2 5 8 11 # Select all rows and column 3 my_matrix[ ,3] ## [1] 7 8 9 If you need to select multiple rows or columns, simply indicate all the indices of interest. Remember that these must be specified in a single vector. Within the square brackets, R expects a single comma separating row indices from column indices. You can use compact notation 1:3 to select rows or columns in succession, which is equivalent to c(1,2,3). # Select rows 1 and 3 my_matrix[c(1,3), ] ## [,1] [,2] [,3] [,4] ## [1,] 1 4 7 10 ## [2,] 3 6 9 12 # Select columns 2 to 4 my_matrix[ , 2:4] ## [,1] [,2] [,3] ## [1,] 4 7 10 ## [2,] 5 8 11 ## [3,] 6 9 12 Selecting Matrix Region By combining row and column indices, it is also possible to select specific regions of a matrix or select some of its values to create a new matrix. # Select a block my_matrix[1:2, 3:4] ## [,1] [,2] ## [1,] 7 10 ## [2,] 8 11 # Select scattered values my_matrix[c(1,3), c(2,4)] ## [,1] [,2] ## [1,] 4 10 ## [2,] 6 12 Remember that, as with vectors, the selection operation does not modify the original object. Therefore, you need to save the result of the selection if you want to keep the changes. The most observant will have noticed that the selection commands do not always return the same object; sometimes we obtain a vector and other times a matrix. It is important to clarify that a vector is not a matrix, and vice versa. In R, these are two different types of objects, and it is important to keep this distinction in mind. # A vector is not a matrix my_vector = 1:5 is.vector(my_vector) # TRUE is.matrix(my_vector) # FALSE # A matrix is not a vector my_matrix = matrix(1, nrow = 3, ncol = 3) is.vector(my_matrix) # FALSE is.matrix(my_matrix) # TRUE The result we obtain from a selection could be either a vector or a matrix depending on the type of selection. In particular, when selecting a single column (or row), we get a vector, while selecting multiple columns (or rows) results in a matrix. # Select a column is.vector(my_matrix[, 1]) # TRUE is.matrix(my_matrix[, 1]) # FALSE # Select multiple columns is.vector(my_matrix[, c(1,2)]) # FALSE is.matrix(my_matrix[, c(1,2)]) # TRUE This distinction will affect the subsequent use of the object obtained from the selection. Row Vector and Column Vector A particular source of misunderstandings and subsequent errors involves using a vector obtained from selecting a single row (or a single column) of a matrix as if it were a row vector (or a column vector). In linear algebra, row vectors and column vectors are simply matrices of dimensions \\(1\\times n\\) and \\(m \\times 1\\), respectively. The dimensions (\\(rows \\times columns\\)) of a matrix, and thus of a vector, play an important role in matrix operations, particularly in matrix multiplication. In R, vectors have only one dimension, which is length, and thus when used with matrix operations, they are automatically converted to row vectors or column vectors as needed. However, this transformation may not always respect the actual intentions, so it is better to always use matrices rather than vectors. # Vector my_vector = 1:4 dim(my_vector) ## NULL length(my_vector) ## [1] 4 # 1x4 matrix (row vector) my_row_vector = matrix(1:4, nrow = 1, ncol = 4) dim(my_row_vector) ## [1] 1 4 my_row_vector ## [,1] [,2] [,3] [,4] ## [1,] 1 2 3 4 # 4x1 matrix (column vector) my_col_vector = matrix(1:4, nrow = 4, ncol = 1) dim(my_col_vector) ## [1] 4 1 my_col_vector ## [,1] ## [1,] 1 ## [2,] 2 ## [3,] 3 ## [4,] 4 “Flattening” a Matrix We have seen that we can easily populate a matrix with a vector. Similarly, we can vectorize a matrix (in other words, “flatten” the matrix) to return to the original vector. Using the command c(matrix) or forcing the object type to vector with vector(matrix) or as.vector(matrix). # From matrix to vector my_matrix = matrix(1:12, nrow = 3, ncol = 4) c(my_matrix) ## [1] 1 2 3 4 5 6 7 8 9 10 11 12 as.vector(my_matrix) ## [1] 1 2 3 4 5 6 7 8 9 10 11 12 9.2.1 Advanced Selection Uses Now let’s explore some advanced uses of selecting elements from a matrix. In particular, we will learn to: use relational and logical operators to select elements of a matrix change the order of rows and columns replace elements delete rows or columns Note that these operations are analogous to those seen for vectors and therefore will follow the same rules and principles. Relational and Logical Operators A useful function is to select among the elements of a matrix those that meet a certain condition. For example, we can evaluate “which elements of the matrix are greater than x?”. To do this, we must specify within the square brackets the proposition of interest using relational and logical operators (see Chapter 3.2). When a matrix is evaluated within a proposition, R evaluates the truth of that proposition concerning each of its elements. As a result, we obtain a matrix of logical values with the respective answers for each element (TRUE or FALSE). my_matrix = matrix(1:23, nrow = 3, ncol = 4) ## Warning in matrix(1:23, nrow = 3, ncol = 4): data length [23] is not a ## sub-multiple or multiple of the number of rows [3] my_matrix ## [,1] [,2] [,3] [,4] ## [1,] 1 4 7 10 ## [2,] 2 5 8 11 ## [3,] 3 6 9 12 # Elements greater than 4 and less than 10 test = my_matrix &gt;= 4 &amp; my_matrix &lt;=10 test ## [,1] [,2] [,3] [,4] ## [1,] FALSE TRUE TRUE TRUE ## [2,] FALSE TRUE TRUE FALSE ## [3,] FALSE TRUE TRUE FALSE This matrix can be used within the square brackets to select elements of the original matrix that satisfy the proposition. Elements associated with the TRUE value are selected, while those associated with FALSE are discarded. # Select the elements my_matrix[test] ## [1] 4 5 6 7 8 9 10 Note that in this case no comma is necessary within the square brackets, and the result obtained is a vector. Change Order of Rows and Columns Row and column indices can be used to reorder the rows and columns of a matrix as needed. my_matrix = matrix(1:6, nrow = 3, ncol = 4) my_matrix ## [,1] [,2] [,3] [,4] ## [1,] 1 4 1 4 ## [2,] 2 5 2 5 ## [3,] 3 6 3 6 # Change the order of the rows my_matrix[c(3,2,1), ] ## [,1] [,2] [,3] [,4] ## [1,] 3 6 3 6 ## [2,] 2 5 2 5 ## [3,] 1 4 1 4 # Change the order of the columns my_matrix[ ,c(1,3,2, 4)] ## [,1] [,2] [,3] [,4] ## [1,] 1 1 4 4 ## [2,] 2 2 5 5 ## [3,] 3 3 6 6 Modify Elements An important use of indices relates to modifying an element of a matrix. To replace an old value with a new value, select the old value of the matrix and use the = (or &lt;-) operator to assign the new value. my_matrix = matrix(1:12, nrow = 3, ncol = 4) my_matrix ## [,1] [,2] [,3] [,4] ## [1,] 1 4 7 10 ## [2,] 2 5 8 11 ## [3,] 3 6 9 12 # Modify the element with the value 5 my_matrix[2,2] = 555 my_matrix ## [,1] [,2] [,3] [,4] ## [1,] 1 4 7 10 ## [2,] 2 555 8 11 ## [3,] 3 6 9 12 It is also possible to replace all values in an entire row or column that has been appropriately selected. In this case, you must provide the correct number of new values to use. # Modify the 2nd column my_matrix[ ,2] = c(444, 555, 666) my_matrix ## [,1] [,2] [,3] [,4] ## [1,] 1 444 7 10 ## [2,] 2 555 8 11 ## [3,] 3 666 9 12 # Modify the 3rd row my_matrix[3, ] = c(111, 666, 999, 122) my_matrix ## [,1] [,2] [,3] [,4] ## [1,] 1 444 7 10 ## [2,] 2 555 8 11 ## [3,] 111 666 999 122 Note that, unlike vectors, it is not possible to add a new row or column through this operation; a different procedure must be used instead (see Chapter 9.3.2). # Attempt to add a new column [index selection error] my_matrix[, 5] = c(27, 27, 27) ## Error in `[&lt;-`(`*tmp*`, , 5, value = c(27, 27, 27)): subscript out of bounds Deleting Rows or Columns To delete rows (or columns) from a matrix, you need to specify the row (or column) indices you want to remove inside the square brackets, preceded by the - (minus) operator. In the case of multiple rows (or columns), you can only indicate the minus sign before the c() command, similar to what is done with vectors. my_matrix = matrix(1:12, nrow = 3, ncol = 4) # Delete the 2nd row my_matrix[-2, ] ## [,1] [,2] [,3] [,4] ## [1,] 1 4 7 10 ## [2,] 3 6 9 12 # Delete the 2nd row and the 2nd and 3rd columns my_matrix[-2, -c(2,3)] ## [,1] [,2] ## [1,] 1 10 ## [2,] 3 12 Note that the deletion operation is still a selection operation. Therefore, you need to save the resulting matrix if you want to keep the changes. Exercises Using the matrices created in the previous exercises, complete the following tasks (solutions): Using the row and column indices, select the number 27 from matrix A. Select the elements between the second and fourth rows and the second and third columns of matrix B. Select only the even elements of matrix A (Note: use the modulus operation %%). Remove the third row and the third column from matrix C. Select all elements from the second and third rows of matrix B. Select all elements other than “B” from matrix D. 9.3 Functions and Operations Now let’s look at some frequently used functions and common operations performed with matrices (see Table 9.1). Table 9.1: Table 9.2: Functions and operations with matrices Function Description new_matrix = &lt;- cbind(matrix1, matrix2) Combine two matrices creating new columns (the matrices must have the same number of rows) new_matrix = &lt;- rbind(matrix1, matrix2) Combine two matrices creating new rows (the matrices must have the same number of columns) nrow(matrix_name) Number of rows in the matrix ncol(matrix_name) Number of columns in the matrix dim(matrix_name) Dimensions of the matrix (rows and columns) colnames(matrix_name) Names of the matrix columns rownames(matrix_name) Names of the matrix rows dimnames(matrix_name) Names of the rows and columns t(matrix_name) Transpose of the matrix diag(matrix_name) Vector with the elements of the matrix diagonal det(matrix_name) Determinant of the matrix (the matrix must be square) solve(matrix_name) Inverse of the matrix matrix1 + matrix2 Element-wise sum of two matrices matrix1 - matrix2 Element-wise difference between two matrices matrix1 * matrix2 Element-wise product of two matrices matrix1 / matrix2 Element-wise division between two matrices matrix1 %*% matrix2 Matrix product Let’s now describe some specific uses in detail. 9.3.1 Attributes of a Matrix We have seen in Chapter 8.1 that objects in R have what are called attributes, which are useful information regarding the object itself, a sort of metadata. Now let’s look at some attributes particularly relevant in the case of matrices, namely the dimensions (dim) and the names of the rows and columns (names). Dimensions Recall that a matrix is a two-dimensional object made up of rows and columns. These form the dimensions of a matrix. To obtain the number of rows and columns in a matrix, we can use the commands nrow() and ncol(), respectively. my_matrix = matrix(1:12, ncol = 3, nrow = 4) # Number of rows nrow(my_matrix) ## [1] 4 # Number of columns ncol(my_matrix) ## [1] 3 Alternatively, to find out the dimensions of a matrix, you can use the dim() function. This will return a vector with two values where the first represents the number of rows and the second the number of columns. dim(my_matrix) ## [1] 4 3 Row and Column Names As you may have noticed, by default, the dimensions of a matrix (that is, rows and columns) are identified by their numerical indices. However, in R, it is also possible to assign names to the rows and columns of a matrix. With the commands rownames() and colnames(), we can access the names of the rows and columns, respectively. my_matrix = matrix(1:12, nrow = 3, ncol = 4) # Names of rows rownames(mat) ## NULL # Names of columns colnames(mat) ## NULL Since they are not set initially, we get NULL as the output. To set the names of rows and/or columns, you will need to assign to rownames(matrix_name) and colnames(matrix_name) a character vector of the same length as the dimension you are renaming. If you set a single character, all rows/columns will have the same value. This tells us that if we want to set names, R requires this to be done for all rows/columns. # Assign names to the rows rownames(my_matrix) = LETTERS[1:3] my_matrix ## [,1] [,2] [,3] [,4] ## A 1 4 7 10 ## B 2 5 8 11 ## C 3 6 9 12 # Assign names to the columns colnames(my_matrix) = LETTERS[4:7] my_matrix ## D E F G ## A 1 4 7 10 ## B 2 5 8 11 ## C 3 6 9 12 Alternatively, you can use dimnames() to access both row and column names simultaneously. The output will be a list (see Chapter 11) where the row names are indicated first, followed by the column names. dimnames(my_matrix) ## [[1]] ## [1] &quot;A&quot; &quot;B&quot; &quot;C&quot; ## ## [[2]] ## [1] &quot;D&quot; &quot;E&quot; &quot;F&quot; &quot;G&quot; When we explored different ways to select elements of a matrix in Chapter 9.2, we always used numerical row and column indices. However, when dimension names are available, it is possible to index a matrix based on the names of the rows and/or columns. We can select the first column both by its numerical index matrix_name[ , 1] and by its assigned name matrix_name[ ,\"column_name\"]. These operations are not particularly useful with matrices but will be essential in the case of dataframes (see Chapter 10). # Select column &quot;F&quot; my_matrix[ , &quot;F&quot;] ## A B C ## 7 8 9 # Select rows &quot;A&quot; and &quot;C&quot; my_matrix[c(&quot;A&quot;, &quot;C&quot;), ] ## D E F G ## A 1 4 7 10 ## C 3 6 9 12 9.3.2 Combining Matrices We have seen in Chapter 7.3 how to combine different vectors using the c() function. It is also possible to combine different matrices, but some rules must be followed: rbind() - I can combine matrices by row, adding one or more rows to a matrix; in this case, the matrices must have the same number of columns. cbind() - I can combine matrices by column, adding one or more columns to a matrix; in this case, the matrices must have the same number of rows. The matrices being combined must be of the same type (numbers or characters). So, given a matrix my_matrix of size \\(m \\times n\\), if we want to add the rows of a second matrix row_matrix, we can use the command rbind(my_matrix, row_matrix) provided they have the same number of columns (\\(n\\)). If we want to add the columns of a new matrix col_matrix, we can use the command cbind(my_matrix, col_matrix) provided they have the same number of rows (\\(m\\)). It is useful to think of the combination as a collage of matrices. In Figure 9.2, there is a diagram that helps to visually understand this concept, where the matrices colored in green can be correctly combined, while those in red do not have the correct dimensionality. Figure 9.2: Scheme for Matrix Combination Let’s see an example in R: # Starting matrix my_matrix = matrix(1:12, nrow = 3, ncol = 4) my_matrix ## [,1] [,2] [,3] [,4] ## [1,] 1 4 7 10 ## [2,] 2 5 8 11 ## [3,] 3 6 9 12 # Matrix with the same number of columns row_matrix = matrix(77, nrow = 2, ncol = 4) row_matrix ## [,1] [,2] [,3] [,4] ## [1,] 77 77 77 77 ## [2,] 77 77 77 77 # Combine by row rbind(my_matrix, row_matrix) ## [,1] [,2] [,3] [,4] ## [1,] 1 4 7 10 ## [2,] 2 5 8 11 ## [3,] 3 6 9 12 ## [4,] 77 77 77 77 ## [5,] 77 77 77 77 # Matrix with the same number of rows col_matrix = matrix(99, nrow = 3, ncol = 2) col_matrix ## [,1] [,2] ## [1,] 99 99 ## [2,] 99 99 ## [3,] 99 99 # Combine by column cbind(my_matrix, col_matrix) ## [,1] [,2] [,3] [,4] [,5] [,6] ## [1,] 1 4 7 10 99 99 ## [2,] 2 5 8 11 99 99 ## [3,] 3 6 9 12 99 99 An additional useful aspect is the extension of the cbind() and rbind() commands. Until now, we have used them with just two elements: the starting matrix and the matrix to add. However, it is possible to indicate multiple matrices to combine, separating them with a comma. If we want to combine \\(n\\) matrices, we can use the command cbind(mat1, mat2, mat3, ...) or rbind(mat1, mat2, mat3, ...). In this case, the final result will be the combination of the matrices in the order used to define the arguments, with mat1 first, then mat2, and so on. We have seen that we can combine matrices by row/column only if the number of columns/rows of the two matrices matches. We get an error instead when trying to combine matrices of different dimensions: “number of columns/rows of matrices must match”. my_matrix = matrix(1:12, nrow = 3, ncol = 4) # Matrix with incorrect number of columns wrong_matrix = matrix(77, nrow = 2, ncol = 7) rbind(my_matrix, wrong_matrix) ## Error in rbind(my_matrix, wrong_matrix): number of columns of matrices must match (see arg 2) 9.3.3 Mathematical Operators Mathematical operators (e.g., +, -, *, /) perform operations between a matrix and a single value, between a matrix and a vector, or between two matrices. Operation between Matrix and Single Value In the case of a single value, the same operation is simply performed on all elements of the matrix. For example, we can add 100 to all elements of a matrix. my_matrix = matrix(1:12, nrow = 3, ncol = 4) my_matrix ## [,1] [,2] [,3] [,4] ## [1,] 1 4 7 10 ## [2,] 2 5 8 11 ## [3,] 3 6 9 12 # Add 100 my_matrix + 100 ## [,1] [,2] [,3] [,4] ## [1,] 101 104 107 110 ## [2,] 102 105 108 111 ## [3,] 103 106 109 112 Operation between Matrix and Vector In the case of a vector, the operation is performed element by element, cycling the values of the vector if its length is insufficient. For example, we can add the vector of values c(100, 200, 300, 400) to all elements of a matrix. # Add a vector of values my_matrix + c(100, 200, 300, 400) ## [,1] [,2] [,3] [,4] ## [1,] 101 404 307 210 ## [2,] 202 105 408 311 ## [3,] 303 206 109 412 As can be easily understood, this operation is not advisable since it can easily lead to errors and misunderstandings. Operation between Matrices In the case of operations between matrices, the operation is performed element by element, so it is important that the matrices have the same dimensions. For example, we can add to all elements of a matrix where the rows contain the values 100, 200, 300, and 400. sum_matrix = matrix(rep(c(100, 200, 300, 400), each = 3), nrow = 3, ncol = 4) sum_matrix ## [,1] [,2] [,3] [,4] ## [1,] 100 200 300 400 ## [2,] 100 200 300 400 ## [3,] 100 200 300 400 # Sum two matrices my_matrix + sum_matrix ## [,1] [,2] [,3] [,4] ## [1,] 101 204 307 410 ## [2,] 102 205 308 411 ## [3,] 103 206 309 412 Note that in R, the * operator indicates simple element-wise multiplication, while to obtain the matrix product, the operator %*% must be used. Matrix multiplication follows specific rules and properties. In particular, the number of columns in the first matrix must equal the number of rows in the second matrix. For more information, see https://en.wikipedia.org/wiki/Matrix_multiplication. Linear Algebra Other aspects concerning matrix operations are not discussed here but interested readers can refer to the following pages: For the meaning of the determinant of a matrix, see https://en.wikipedia.org/wiki/Determinant For the meaning of the inverse matrix see https://en.wikipedia.org/wiki/Invertible_matrix Diagonal Now let’s look at some useful functions related to the diagonal of a matrix. The diagonal of a matrix is formed by the elements whose row and column indices are equal, that is, the set of elements associated with the same row and column index (\\(x_{i,i}\\)). The command diag(matrix_name) allows you to extract the diagonal of a matrix and treat it as a simple vector: # Square matrix square_matrix = matrix(1:16, nrow = 4, ncol = 4) square_matrix ## [,1] [,2] [,3] [,4] ## [1,] 1 5 9 13 ## [2,] 2 6 10 14 ## [3,] 3 7 11 15 ## [4,] 4 8 12 16 diag(square_matrix) ## [1] 1 6 11 16 # Non-square matrix my_matrix = matrix(1:12, nrow = 3, ncol = 4) my_matrix ## [,1] [,2] [,3] [,4] ## [1,] 1 4 7 10 ## [2,] 2 5 8 11 ## [3,] 3 6 9 12 diag(my_matrix) ## [1] 1 5 9 The diag() function can also be used to easily replace elements on the diagonal of a matrix or to create a diagonal matrix where all other values are zero, such as the identity matrix. # Replace the diagonal elements diag(my_matrix) = 999 my_matrix ## [,1] [,2] [,3] [,4] ## [1,] 999 4 7 10 ## [2,] 2 999 8 11 ## [3,] 3 6 999 12 # Create a diagonal matrix diag(4, nrow = 3, ncol = 4) ## [,1] [,2] [,3] [,4] ## [1,] 4 0 0 0 ## [2,] 0 4 0 0 ## [3,] 0 0 4 0 # Create a 4x4 identity matrix diag(4) ## [,1] [,2] [,3] [,4] ## [1,] 1 0 0 0 ## [2,] 0 1 0 0 ## [3,] 0 0 1 0 ## [4,] 0 0 0 1 ::: Exercises Using the matrices created in previous exercises, complete the following tasks (solutions): Create matrix G by combining matrix A with the first two columns of matrix C. Create matrix H by combining matrix C with the first two rows of the transpose of matrix B. Redefine matrix A by removing the second column. Redefine matrix B by removing the first row. Check that the resulting matrices have the same dimensions. Comment on the different results obtained from the operations A*B, B*A, A%*%B, and B%*%A. Assign the following names to the columns and rows of matrix C: \"col_1\", \"col_2\", \"col_3\", \"col_4\", \"row_1\", \"row_2\", \"row_3\". 9.4 Arrays We have seen that matrices are a two-dimensional object, but it is also possible to create objects that have 3, 4, or any number (n) of dimensions. These objects are called arrays and can be created using the array() command, specifying the vector of values used to populate the object and the size of each of its dimensions. array(data = , dim = ) For example, to create a cube of side 3 containing integer values from 1 to 27, we can execute the following command. my_cube = array(1:27, dim = c(3,3,3)) my_cube ## , , 1 ## ## [,1] [,2] [,3] ## [1,] 1 4 7 ## [2,] 2 5 8 ## [3,] 3 6 9 ## ## , , 2 ## ## [,1] [,2] [,3] ## [1,] 10 13 16 ## [2,] 11 14 17 ## [3,] 12 15 18 ## ## , , 3 ## ## [,1] [,2] [,3] ## [1,] 19 22 25 ## [2,] 20 23 26 ## [3,] 21 24 27 All the main functions and selection operations we have seen for matrices and vectors can also be performed similarly with arrays. The general functioning of selecting elements using square brackets will now be clearer. For each dimension, the desired position indices are indicated. The order within the square brackets determines which specific dimension is being referred to, and commas are used to separate indices of different dimensions. my_hypercube[&lt;dim-1&gt;, &lt;dim-2&gt;, &lt;dim-3&gt;, ..., &lt;dim-n&gt;] Let’s now see some simple examples of selection. ## [1] 1 ## [1] 1 2 3 ## [,1] [,2] [,3] ## [1,] 1 4 7 ## [2,] 2 5 8 ## [3,] 3 6 9 ## , , 1 ## ## [,1] [,2] ## [1,] 1 4 ## [2,] 2 5 ## ## , , 2 ## ## [,1] [,2] ## [1,] 10 13 ## [2,] 11 14 It is easy to see that matrices are simply a special case of arrays with 2 dimensions. In fact, the observant will have noticed that the value \"array\" appeared alongside \"matrix\" when evaluating the type of the object. my_matrix = matrix(1:12, nrow = 2, ncol = 2) ## Warning in matrix(1:12, nrow = 2, ncol = 2): data length differs from size of ## matrix: [12 != 2 x 2] is.array(my_matrix) ## [1] TRUE class(my_matrix) ## [1] &quot;matrix&quot; &quot;array&quot; However, note that a simple vector is not an array. Recall that a vector does not possess a dimension (dim) but simply a length (length). my_vector = 1:12 is.array(my_vector) ## [1] FALSE dim(my_vector) ## NULL "],["dataframe.html", "Chapter10 Dataframe 10.1 Creating a dataframe 10.2 Selecting Elements 10.3 Functions and Operations", " Chapter10 Dataframe Dataframes are one of the most commonly used objects in R for representing data. Similar to a matrix, a dataframe is a two-dimensional structure where data is organized in rows and columns. It can be helpful to think of a data frame just like a regular table you might create in a spreadsheet (e.g., Excel) where you can enter your data. The term “data” here is intentionally broad because, unlike matrices, data frames can contain different types of data within the same object (e.g., names, dates, and numbers). The basic structure of a dataframe is thus the same as a matrix, but it allows us to include various data types in the same object, such as characters and numerical values. This enables us to store all the features of statistical units (e.g., numerical, categorical, nominal variables, etc.) that we aim to analyze later. A crucial point is that dataframes are designed to handle complex and heterogeneous data, typical in real data analysis. If you use other programming languages geared toward data analysis (e.g., Matlab), you’ll notice the lack of a powerful and intuitive object like the dataframe. Generally, in a dataframe, rows represent statistical units (e.g., people or observations), and columns represent variables, which are properties measured on those units. However, there are two main dataframe formats depending on how the data is organized: wide dataframes and long dataframes. Let’s evaluate the difference between the two formats by considering data where, for each subject, we measure age, gender, and responses to three items in a questionnaire. Wide Dataframe In the wide format, each row of the dataframe represents a subject, and each of their responses or measured variables is reported in a different column. Even repeated responses to the same type of variable, such as questionnaire items, experimental trials, or the same variable measured at multiple time points are presented in different columns, so that whatever has been collected for a single participant is reported in one and a single row. The wide format is arguably the most familiar to researchers who routinely perform analyses with the SPSS software. In Table 10.1, some example data is presented in wide format: notice how responses to different items are reported in multiple columns. Table 10.1: Table 10.2: Dataframe in wide format Id age gender item_1 item_2 item_3 subj_1 21 F 2 0 2 subj_2 23 M 1 2 0 subj_3 19 F 1 1 1 We see that each subject is identified by a code in the Id variable, and their responses to the three items are reported in three different variables item_1, item_2, and item_3. Long Dataframe In the long format, each row represents a single observation. Therefore, the data for each subject is spread across multiple rows, and variables that don’t change across observations are repeated. In Table 10.3, the example data is presented in long format. Table 10.3: Table 10.4: Dataframe in long format Id age gender item response subj_1 21 F 1 2 subj_1 21 F 2 1 subj_1 21 F 3 1 subj_2 23 M 1 0 subj_2 23 M 2 2 subj_2 23 M 3 1 subj_3 19 F 1 2 subj_3 19 F 2 0 subj_3 19 F 3 1 We observe that each subject’s responses are spread across multiple rows. The characteristics that do not vary are repeated in each row (Id, age, and gender), while the responses to the items are recorded using two columns: item, which represents the item number, and response, which records the subject’s actual response to that specific item. Long and wide data formats have different properties, especially in terms of usage. The type of data and the final result are the same; however, some software or R packages work only with datasets organized in a certain way (e.g., lme4 package for fitting mixed-models and ggplot2 for data visualization mostly require long format dataframes, while lavaan package for structural equation modeling mostly require wide format dataframes.) There isn’t a “correct” or “incorrect” format; it depends on the type of analysis and the software or package you’re using. Some operations or analyses require the dataset in long format, while others require it in wide format. However, it’s advisable to become accustomed to thinking in long format because most modern data analysis and visualization packages require the data in this structure. There are also functions for quickly switching from one format to another (e.g., the reshape() function). Note that in the previous examples, we used both numeric and character columns. This wasn’t possible with matrices. However, keep in mind that, just like matrices, dataframes require that all columns (variables) have the same number of elements. Now we’ll see how to create dataframes in R, how to perform common selection operations, and describe some simple manipulations with dataframes. As we’ll see, there are many similarities between using dataframes and matrices. When necessary, we’ll refer to the previous chapter to highlight common aspects and differences between these two data structures. 10.1 Creating a dataframe In most cases, you will probably upload existing data (e.g., from a .csv file containing some collected experimental data) rather than creating a dataframe from scratch in R. However, let’s now see how to create a new dataframe. The command to create a dataframe is data.frame(): nome_df = data.frame( variable1 = c(...), variable2 = c(...), ...) Creating a dataframe is slightly different from matrices. Intuitively, it’s like combining several columns (where one may contain names, another dates, and so on) rather than inserting values by row or column as in matrices. In fact, to create a dataframe, you need to specify the columns one by one, indicating column_name = values within the data.frame() command. Let’s see an example in R: my_data = data.frame( Id = c(1:5), names = c(&quot;Alice&quot;, &quot;Bruno&quot;, &quot;Carla&quot;, &quot;Diego&quot;, &quot;Elisa&quot;), gender = factor(c(&quot;F&quot;,&quot;M&quot;,&quot;F&quot;, &quot;M&quot;, &quot;F&quot;)), age = c(22, 25, 23, 22, 24), faculty = factor(c(&quot;Psychology&quot;, &quot;Engineering&quot;, &quot;Medicine&quot;, &quot;Arts&quot;, &quot;Psychology&quot;)) ) my_data ## Id names gender age faculty ## 1 1 Alice F 22 Psychology ## 2 2 Bruno M 25 Engineering ## 3 3 Carla F 23 Medicine ## 4 4 Diego M 22 Arts ## 5 5 Elisa F 24 Psychology In this case, we’ve created a hypothetical dataframe where each row represents a subject, and each column represents a certain characteristic of that subject, like gender, age, and so on. It’s always recommended to define a column (e.g., Id) where you assign a unique identifier to each subject. This allows you to identify them without risking errors. For example, using a name (or even first and last names) may not be ideal because multiple people could have the same name, making it difficult to distinguish between them. While this may not seem strictly needed when using wide dataframes, as different rows always represent different individuals, that becomes crucial when using long dataframes, as multiple rows may or may not represent data from the same individual. A character variable within a DataFrame is considered by default as a simple sequence of characters. You can specify the argument stringsAsFactors = TRUE to automatically convert all character variables to categorical variables (see Chapter 8 Note that the default behavior depends on the version of R. Versions prior to R 4.0 had stringsAsFactors = TRUE by default, while from R 4.0 onwards, the default is stringsAsFactors = FALSE. So, pay attention when using code written before version 4.0. Exercises Perform the following exercises (solutions): Create the data_wide dataframe shown in Table 10.1. Create the data_long dataframe shown in Table 10.3. 10.2 Selecting Elements To select one or more values from a dataframe, you can use row and column indices within square brackets, similar to matrices: dataframe_name[&lt;row-index&gt;, &lt;column-index&gt;] Remember that the order [&lt;row-index&gt;, &lt;column-index&gt;] is fixed and must be followed for the selection to work correctly. You can perform various types of selections depending on your needs, using the same procedures seen for matrices. For example, using the my_data dataframe created earlier, we can select: my_data ## Id names gender age faculty ## 1 1 Alice F 22 Psychology ## 2 2 Bruno M 25 Engineering ## 3 3 Carla F 23 Medicine ## 4 4 Diego M 22 Arts ## 5 5 Elisa F 24 Psychology ## 6 6 Fabrizio M 35 Arts ## 7 7 Gloria F 26 Engineering ## 8 8 Herman M 20 Psychology ## 9 9 Irene F 23 Statistics ## 10 10 Luca M 22 Engineering # Value in 3rd row and 2nd column my_data[3,4] ## [1] 23 # All variables of the 1st and 3rd rows my_data[c(2,3), ] ## Id names gender age faculty ## 2 2 Bruno M 25 Engineering ## 3 3 Carla F 23 Medicine # All values of the 5th variable my_data[ , 5] ## [1] Psychology Engineering Medicine Arts Psychology Arts ## [7] Engineering Psychology Statistics Engineering ## Levels: Arts Engineering Medicine Psychology Statistics # Values of the 2nd and 4th variables for the 3rd and 5th rows my_data[c(3,5), c(2,4)] ## names age ## 3 Carla 23 ## 5 Elisa 24 However, when working with dataframes, it’s more common to refer to the column names and use logical conditions to select values of interest. Selecting Columns by Variable Names One significant difference between matrices and dataframes is that you can access columns using the $ operator and the column name, using the following syntax: dataframe_name$variable_name This allows you to access that specific column directly without using indices and square brackets. For example: # Select the &quot;names&quot; variable my_data$names ## [1] &quot;Alice&quot; &quot;Bruno&quot; &quot;Carla&quot; &quot;Diego&quot; &quot;Elisa&quot; &quot;Fabrizio&quot; ## [7] &quot;Gloria&quot; &quot;Herman&quot; &quot;Irene&quot; &quot;Luca&quot; # Select the &quot;faculty&quot; variable my_data$faculty ## [1] Psychology Engineering Medicine Arts Psychology Arts ## [7] Engineering Psychology Statistics Engineering ## Levels: Arts Engineering Medicine Psychology Statistics Alternatively, you can use the usual square bracket selection method by specifying the column names instead of column indices. This allows you to select multiple variables at once. For example: # Select only the &quot;names&quot; variable my_data[ , &quot;names&quot;] ## [1] &quot;Alice&quot; &quot;Bruno&quot; &quot;Carla&quot; &quot;Diego&quot; &quot;Elisa&quot; &quot;Fabrizio&quot; ## [7] &quot;Gloria&quot; &quot;Herman&quot; &quot;Irene&quot; &quot;Luca&quot; # Select the &quot;names&quot;, &quot;gender&quot;, and &quot;faculty&quot; variables my_data[ , c(&quot;names&quot;, &quot;gender&quot;, &quot;faculty&quot;)] ## names gender faculty ## 1 Alice F Psychology ## 2 Bruno M Engineering ## 3 Carla F Medicine ## 4 Diego M Arts ## 5 Elisa F Psychology ## 6 Fabrizio M Arts ## 7 Gloria F Engineering ## 8 Herman M Psychology ## 9 Irene F Statistics ## 10 Luca M Engineering Note that the variable names must be provided as strings. Selecting Rows with Logical Conditions We’ve seen earlier how to construct logical propositions to select only values that meet a certain condition in the case of vectors and matrices. Now, this function becomes particularly useful as it allows us to query the dataframe in a simple and intuitive way. By using a logical condition, we can filter the observations that satisfy a given condition and retrieve only the information of interest. In the canonical syntax [&lt;row-index&gt;, &lt;column-index&gt;], the row indices are replaced with a logical condition to filter the rows, and the column indices are replaced with the names of the variables of interest. We use the following syntax: dataframe_name[&lt;logical_condition_rows&gt;, &lt;variable_names&gt;] Here are some examples of selection: # All data for &quot;Diego&quot; (Id == 4) my_data[my_data$Id == 4 , ] ## Id names gender age faculty ## 4 4 Diego M 22 Arts # All data for females my_data[my_data$gender == &quot;F&quot; , ] ## Id names gender age faculty ## 1 1 Alice F 22 Psychology ## 3 3 Carla F 23 Medicine ## 5 5 Elisa F 24 Psychology ## 7 7 Gloria F 26 Engineering ## 9 9 Irene F 23 Statistics # Faculties of subjects older than 24 years my_data[my_data$age &gt; 24 , c(&quot;age&quot;, &quot;faculty&quot;)] ## age faculty ## 2 25 Engineering ## 6 35 Arts ## 7 26 Engineering Note that when defining a logical condition using the dataframe’s variables, it’s still necessary to include the dataframe name. In the previous example, we would have encountered an error by simply using age &gt; 24, as this would refer to the object age (which doesn’t exist), not the age variable contained in my_data. my_data[age &gt; 24 , c(&quot;age&quot;, &quot;faculty&quot;)] ## Error in eval(expr, envir, enclos): object &#39;age&#39; not found Similarly to what we saw with vectors, using the condition my_data$age &gt; 24 returns a vector of TRUE and FALSE values depending on whether the condition is met or not. By using logical operators AND (&amp;), OR (|), and NOT (!), we can combine multiple logical operations to create more complex, yet still intuitive, indexing queries. For example, to select “subjects between 20 and 25 years old enrolled in psychology,” we would write: my_data[my_data$age&gt;=20 &amp; my_data$age&lt;=25 &amp; my_data$faculty==&quot;Psychology&quot; , ] ## Id names gender age faculty ## 1 1 Alice F 22 Psychology ## 5 5 Elisa F 24 Psychology ## 8 8 Herman M 20 Psychology By using this indexing method, we can appreciate the true power of dataframes. We now have a very simple and intuitive method for working with complex data structures that contain different data types. Two important aspects regarding the result of a selection are the type of output obtained and how to save it. Output Type Similarly to matrices, selection commands do not always return the same type of object. When we select a single variable, the result is a vector, while selecting two or more variables returns a dataframe. # Single variable class(my_data$age) ## [1] &quot;numeric&quot; # Multiple variables class(my_data[ , c(&quot;names&quot;, &quot;age&quot;)]) ## [1] &quot;data.frame&quot; Saving the Selection As with other types of objects, selection operations do not modify the original object. Therefore, if you wish to keep the changes, you need to save the result of the selection. It’s advisable to create a new object and not overwrite the original one, as this will allow you to make new selections or operations on the original data. It’s good practice to always keep one copy of the dataframe containing the original version of the data. 10.2.1 Advanced Selection Uses Let’s now look at some advanced uses of selecting elements from a dataframe. Modifying Elements Similar to other objects, we can modify values by selecting the old value in the dataframe and using the = (or &lt;-) operator to assign the new value. my_data[1:5 , ] ## Id names gender age faculty ## 1 1 Alice F 22 Psychology ## 2 2 Bruno M 25 Engineering ## 3 3 Carla F 23 Medicine ## 4 4 Diego M 22 Arts ## 5 5 Elisa F 24 Psychology # Replace the name in the 4th row with &quot;Davide&quot; my_data[4 , &quot;names&quot;] = &quot;Davide&quot; my_data[1:5 , ] ## Id names gender age faculty ## 1 1 Alice F 22 Psychology ## 2 2 Bruno M 25 Engineering ## 3 3 Carla F 23 Medicine ## 4 4 Davide M 22 Arts ## 5 5 Elisa F 24 Psychology Remove Rows or Columns Similarly to matrices, to remove rows (or columns) from a dataframe, you need to indicate the row (or column) indices to remove within square brackets, preceded by the - (minus) operator. # Remove the first 5 observations/rows my_data[-c(1:5) , ] ## Id names gender age faculty ## 6 6 Fabrizio M 35 Arts ## 7 7 Gloria F 26 Engineering ## 8 8 Herman M 20 Psychology ## 9 9 Irene F 23 Statistics ## 10 10 Luca M 22 Engineering # Remove the third column my_data[ , -3] ## Id names age faculty ## 1 1 Alice 22 Psychology ## 2 2 Bruno 25 Engineering ## 3 3 Carla 23 Medicine ## 4 4 Davide 22 Arts ## 5 5 Elisa 24 Psychology ## 6 6 Fabrizio 35 Arts ## 7 7 Gloria 26 Engineering ## 8 8 Herman 20 Psychology ## 9 9 Irene 23 Statistics ## 10 10 Luca 22 Engineering You can also exclude (and in a sense remove) information using logical operators such as NOT (i.e., !) and not equal to (!=). In the following examples, only rows where the faculty information is not equal to (i.e., different from) Psychology are kept (so, observations associated with Psychology are practically removed from the dataframe): # Select everything except psychology students my_data[my_data$faculty != &quot;Psychology&quot; , ] ## Id names gender age faculty ## 2 2 Bruno M 25 Engineering ## 3 3 Carla F 23 Medicine ## 4 4 Davide M 22 Arts ## 6 6 Fabrizio M 35 Arts ## 7 7 Gloria F 26 Engineering ## 9 9 Irene F 23 Statistics ## 10 10 Luca M 22 Engineering Removing multiple categories, such as both Psychology and Statistics while keeping the rest may be a bit more difficult. Here are two possible methods, the second one may be more efficient when writing: # method 1 : keep rows where &quot;faculty&quot; is not &quot;Psychology&quot; AND not &quot;Statistics&quot; my_data[my_data$faculty != &quot;Psychology&quot; &amp; my_data$faculty != &quot;Statistics&quot; , ] ## Id names gender age faculty ## 2 2 Bruno M 25 Engineering ## 3 3 Carla F 23 Medicine ## 4 4 Davide M 22 Arts ## 6 6 Fabrizio M 35 Arts ## 7 7 Gloria F 26 Engineering ## 10 10 Luca M 22 Engineering # method 2 : keep all rows but NOT those in the vector c(&quot;Psychology&quot;, &quot;Statistics&quot;) my_data[!my_data$faculty %in% c(&quot;Psychology&quot;,&quot;Statistics&quot;) , ] ## Id names gender age faculty ## 2 2 Bruno M 25 Engineering ## 3 3 Carla F 23 Medicine ## 4 4 Davide M 22 Arts ## 6 6 Fabrizio M 35 Arts ## 7 7 Gloria F 26 Engineering ## 10 10 Luca M 22 Engineering A strategy similar to the second method shown just above could be used for removing multiple columns by names. Actually, the - (minus) will not work when listing columns by name. Let’s say we want to visualize the my_data dataframe but removing the columns related to gender and age. We may proceed as follow: # Select all column names that are NOT in the vector c(&quot;gender&quot;,&quot;age&quot;) my_data[ , !colnames(my_data) %in% c(&quot;gender&quot;,&quot;age&quot;)] ## Id names faculty ## 1 1 Alice Psychology ## 2 2 Bruno Engineering ## 3 3 Carla Medicine ## 4 4 Davide Arts ## 5 5 Elisa Psychology ## 6 6 Fabrizio Arts ## 7 7 Gloria Engineering ## 8 8 Herman Psychology ## 9 9 Irene Statistics ## 10 10 Luca Engineering Note that the “removal” operation is actually a “selection” operation. Therefore, if you want to keep the changes, you need to save the result. Using the - operator is somewhat risky, especially if the object created (or overwritten) is then used in other operations. Removing information, unless strictly necessary, is not a good practice. If you need to select part of the data, it’s always better to create a new dataframe (or a new object in general) while keeping a version of the original data available. Exercises Referring to the data_long and data_wide dataframes created earlier, complete the following exercises (solutions): Using numeric indices for rows and columns, select the data for the subject subj_2 regarding the item and response variables from the data_long dataframe. Perform the same selection as the previous exercise, but this time use a logical condition for the row indices and specify the column names directly. In the data_wide dataframe, select the Id and gender variables for subjects who responded with 1 to the item_1 variable. In the data_long dataframe, select only the data for girls older than 20 years. Remove the observations regarding subj_2 and the \"gender\" variable from the data_long dataframe. 10.3 Functions and Operations Now, let’s look at some commonly used functions and operations performed with dataframes (see Table 10.5). Table 10.5: Table 10.6: Functions and operations with dataframes Function Description nrow(nome_df) Number of observations in the dataframe ncol(nome_df) Number of variables in the dataframe colnames(nome_df) Column names of the dataframe rownames(nome_df) Row names of the dataframe nome_df &amp;lt;-&lt;br&gt; cbind(nome_df, dati) &lt;br&gt; nome_df$nome_var &amp;lt;-&lt;br&gt; dati Add a new variable to the dataframe (must have the same number of rows) nome_df &amp;lt;- rbind(nome_df, dati) Add observations (new data must match the structure of the dataframe) head(nome_df) First rows of the dataframe tail(nome_df) Last rows of the dataframe str(nome_df) Structure of the dataframe summary(nome_df) Summary of the dataframe We will now describe in detail some particular uses, considering an example of a reduced version of the my_data dataframe created earlier. data_short = my_data[1:5, ] data_short ## Id names gender age faculty ## 1 1 Alice F 22 Psychology ## 2 2 Bruno M 25 Engineering ## 3 3 Carla F 23 Medicine ## 4 4 Davide M 22 Arts ## 5 5 Elisa F 24 Psychology 10.3.1 Attributes of a Dataframe We saw in Chapter 8.1 that objects in R possess what are called attributes, useful information about the object itself, akin to metadata. We will now, similarly to matrices, evaluate the dimensions of a dataframe and the names of its rows and columns. Dimensions Recall that a dataframe is a two-dimensional object consisting of rows and columns. To obtain the number of rows and columns in a dataframe, we can use the nrow() and ncol() functions, respectively. # Number of rows nrow(my_data) ## [1] 10 # Number of columns ncol(my_data) ## [1] 5 Alternatively, as with matrices, we can use the dim() function, which returns a vector with two values: the first representing the number of rows and the second the number of columns. Row and Column Names Similarly to matrices, you can access the row and column names using the rownames() and colnames() functions, respectively. By default, dataframes require names only for the columns, while rows are assigned names based on their row indices. However, it’s possible to name rows with arbitrary values, although this is rarely used. # Check the current names rownames(data_short) ## [1] &quot;1&quot; &quot;2&quot; &quot;3&quot; &quot;4&quot; &quot;5&quot; colnames(data_short) ## [1] &quot;Id&quot; &quot;names&quot; &quot;gender&quot; &quot;age&quot; &quot;faculty&quot; To set row and/or column names, assign a character vector of the same length as the dimension you’re renaming to rownames(dataframe_name) or colnames(dataframe_name). # Assign names to the rows rownames(data_short) = paste0(&quot;Subj_&quot;, 1:nrow(data_short)) # Assign names to the columns colnames(data_short) = c(&quot;Id&quot;, &quot;Name&quot;, &quot;Gender&quot;, &quot;Age&quot;, &quot;Faculty&quot;) data_short ## Id Name Gender Age Faculty ## Subj_1 1 Alice F 22 Psychology ## Subj_2 2 Bruno M 25 Engineering ## Subj_3 3 Carla F 23 Medicine ## Subj_4 4 Davide M 22 Arts ## Subj_5 5 Elisa F 24 Psychology Finally, note that the names() function for dataframes is analogous to colnames(), and you can use NULL to remove, for example, row names. names(data_short) ## [1] &quot;Id&quot; &quot;Name&quot; &quot;Gender&quot; &quot;Age&quot; &quot;Faculty&quot; rownames(data_short) = NULL data_short ## Id Name Gender Age Faculty ## 1 1 Alice F 22 Psychology ## 2 2 Bruno M 25 Engineering ## 3 3 Carla F 23 Medicine ## 4 4 Davide M 22 Arts ## 5 5 Elisa F 24 Psychology 10.3.2 Merging Dataframes Similarly to matrices, you can merge multiple dataframes using the cbind() and rbind() functions, with the same dimensionality requirements regarding rows and columns. However, for dataframes, you can also create a new column using the $ operator. Let’s now describe these uses in detail. dataframe$name = new_var With the syntax dataframe$name = new_var, we add a new column named name to the dataframe, taking values from new_var. This new variable must have the same number of values as there are rows in the dataframe. # Add the &quot;average&quot; column data_short$Average = c(27.5, 23.6, 28.3, 29.2, 24.8) # note that this is the same as: average_grades = c(27.5, 23.6, 28.3, 29.2, 24.8) data_short$Average = average_grades data_short ## Id Name Gender Age Faculty Average ## 1 1 Alice F 22 Psychology 27.5 ## 2 2 Bruno M 25 Engineering 23.6 ## 3 3 Carla F 23 Medicine 28.3 ## 4 4 Davide M 22 Arts 29.2 ## 5 5 Elisa F 24 Psychology 24.8 cbind() With the cbind() function, we can add one or more variables to our dataframe. Note that, unlike using the $ operator, the result is not automatically saved; it must be assigned to a new object dataframe = cbind(dataframe, new_var). In this case, the column name will be new_var. If we want to rename the column, we can use the syntax cbind(dataframe, \"name\" = new_var) or name the object directly: # Add the &quot;number_of_exams&quot; variable number_of_exams = c(12, 14, 13, 10, 8) cbind(data_short, number_of_exams) # without specifying the name ## Id Name Gender Age Faculty Average number_of_exams ## 1 1 Alice F 22 Psychology 27.5 12 ## 2 2 Bruno M 25 Engineering 23.6 14 ## 3 3 Carla F 23 Medicine 28.3 13 ## 4 4 Davide M 22 Arts 29.2 10 ## 5 5 Elisa F 24 Psychology 24.8 8 cbind(data_short, &quot;N_exams&quot; = number_of_exams) # specifying the name ## Id Name Gender Age Faculty Average N_exams ## 1 1 Alice F 22 Psychology 27.5 12 ## 2 2 Bruno M 25 Engineering 23.6 14 ## 3 3 Carla F 23 Medicine 28.3 13 ## 4 4 Davide M 22 Arts 29.2 10 ## 5 5 Elisa F 24 Psychology 24.8 8 Again, the new variable must have the same number of values as there are rows in the dataframe. rbind() Adding rows to a dataframe is slightly more complex. You may need to do this for different reasons. For example, you may have collected experimental data from different participants in different .csv files, and now you have to import and combine them in a single dataframe including all data from all participants. Unlike matrices, which by default do not have column names and contain only numbers or strings, to merge two dataframes by row, they must have the same structure, meaning: The same number of columns (as with matrices) The same column names In the following example, we simply add one single row to an existing dataframe: data_short ## Id Name Gender Age Faculty Average ## 1 1 Alice F 22 Psychology 27.5 ## 2 2 Bruno M 25 Engineering 23.6 ## 3 3 Carla F 23 Medicine 28.3 ## 4 4 Davide M 22 Arts 29.2 ## 5 5 Elisa F 24 Psychology 24.8 # New data with the same columns, but named differently new_data = data.frame( Id = 6, Name = &quot;Marta&quot;, Sex = &quot;F&quot;, # note &quot;Sex&quot; instead of &quot;Gender&quot; Age = 44, Faculty = &quot;Philosophy&quot;, Average = 28.7 ) new_data ## Id Name Sex Age Faculty Average ## 1 6 Marta F 44 Philosophy 28.7 rbind(data_short, new_data) # Error! ## Error in match.names(clabs, names(xi)): names do not match previous names # New data with the same columns having the exact same names new_data = data.frame( Id = 6, Name = &quot;Marta&quot;, Gender = &quot;F&quot;, Age = 44, Faculty = &quot;Philosophy&quot;, Average = 28.7 ) rbind(data_short, new_data) ## Id Name Gender Age Faculty Average ## 1 1 Alice F 22 Psychology 27.5 ## 2 2 Bruno M 25 Engineering 23.6 ## 3 3 Carla F 23 Medicine 28.3 ## 4 4 Davide M 22 Arts 29.2 ## 5 5 Elisa F 24 Psychology 24.8 ## 6 6 Marta F 44 Philosophy 28.7 Again, you need to save the result to keep the changes (which we have not done in the above example). 10.3.3 Dataframe Information Finally, let’s look at some very common functions used to get summary information about the data contained in a dataframe: head() (or tail()) allows us to view the first (or last) rows of our dataframe: head(my_data) ## Id names gender age faculty ## 1 1 Alice F 22 Psychology ## 2 2 Bruno M 25 Engineering ## 3 3 Carla F 23 Medicine ## 4 4 Davide M 22 Arts ## 5 5 Elisa F 24 Psychology ## 6 6 Fabrizio M 35 Arts tail(my_data) ## Id names gender age faculty ## 5 5 Elisa F 24 Psychology ## 6 6 Fabrizio M 35 Arts ## 7 7 Gloria F 26 Engineering ## 8 8 Herman M 20 Psychology ## 9 9 Irene F 23 Statistics ## 10 10 Luca M 22 Engineering str() lets us evaluate the structure of the dataset, providing useful information such as the number of observations, the number of variables, and the type of variables: str(my_data) ## &#39;data.frame&#39;: 10 obs. of 5 variables: ## $ Id : int 1 2 3 4 5 6 7 8 9 10 ## $ names : chr &quot;Alice&quot; &quot;Bruno&quot; &quot;Carla&quot; &quot;Davide&quot; ... ## $ gender : Factor w/ 2 levels &quot;F&quot;,&quot;M&quot;: 1 2 1 2 1 2 1 2 1 2 ## $ age : num 22 25 23 22 24 35 26 20 23 22 ## $ faculty: Factor w/ 5 levels &quot;Arts&quot;,&quot;Engineering&quot;,..: 4 2 3 1 4 1 2 4 5 2 summary() gives us summary information about the variables depending on their type: summary(my_data) ## Id names gender age faculty ## Min. : 1.00 Length:10 F:5 Min. :20.00 Arts :2 ## 1st Qu.: 3.25 Class :character M:5 1st Qu.:22.00 Engineering:3 ## Median : 5.50 Mode :character Median :23.00 Medicine :1 ## Mean : 5.50 Mean :24.20 Psychology :3 ## 3rd Qu.: 7.75 3rd Qu.:24.75 Statistics :1 ## Max. :10.00 Max. :35.00 Exercises Referring to the data_long and data_wide dataframes (solutions): Add the numerical variable \"memory_pre\" to both the data_wide and data_long dataframes: ## Id memory_pre ## 1 subj_1 3 ## 2 subj_2 2 ## 3 subj_3 1 Add the categorical variable \"group\" to both the data_wide and data_long dataframes: ## Id group ## 1 subj_1 treatment ## 2 subj_2 treatment ## 3 subj_3 control Aggiungi al DataFrame data_wide i dati del soggetto subj_4 e subj_5. ## Id age gender item_1 item_2 item_3 memory_pre group ## 1 subj_4 25 F 1 0 2 1 treatment ## 2 subj_5 22 M 1 1 0 3 control In the data_wide dataframe, calculate the \"memory_post\" variable as the sum of the items. In the data_long dataframe, rename the variables item_1, item_2, and item_3 to problem_1, problem_2, and problem_3, respectively. "],["list.html", "Chapter11 Lists 11.1 Creating Lists 11.2 Selecting Elements 11.3 Functions and Operations 11.4 Nested Structure", " Chapter11 Lists Lists are one of the most versatile and useful objects in R. We can think of lists as large containers for other objects. The main feature of lists is their ability to contain different types of objects inside them, such as vectors, data frames, matrices, and even other lists. Unlike data frames and matrices, where the elements are related, the elements of a list are completely independent. A list, in fact, can contain completely different objects in both type and size without any relation or constraint. A useful way to imagine a list (see Figure 11.1) is to think of a hotel hallway where each door leads to a room with different characteristics, number of elements, and so on. It is important to note that the elements are arranged in a specific order, allowing them to be identified by their position index, similarly to what we saw with vector elements. Figure 11.1: Conceptual example of a list Practically speaking, a list is a very simple object, similar to a vector, and many of its characteristics are shared with other objects we’ve already encountered. However, the main difficulty lies in its indexing because, due to their versatility, the structures of lists can become quite complex. Let’s now see how to create a list and the different ways to select its elements. As we will see, there are many similarities to the use of data frames and matrices. When necessary, we will refer to the previous chapter to point out common aspects and differences between these two data structures. 11.1 Creating Lists The command to create a list is list(): list_name = list( object_name_1 = object_1, ..., object_name_n = object_n) Although the object_name_x parameter is not necessary, as we will see, it is highly recommended to name all elements of the list to make indexing easier. If we don’t name the elements, they will be identified only by their position index, i.e., a progressive number \\(1...n\\), just like in the case of vectors. This makes subsequent element selection less intuitive. So, if we have different objects in our workspace, such as a simple variable, a vector, and a dataframe, we can gather all these elements into a single list. For example: # A variable my_value = &quot;Test&quot; # A vector my_vector = c(1, 3, 5, 6, 10) # A data frame my_data = data.frame(id = 1:6, gender = rep(c(&quot;m&quot;, &quot;f&quot;), times = 3), y = 1:6) # Create the list my_list = list(element_1 = my_value, element_2 = my_vector, element_3 = my_data) my_list ## $element_1 ## [1] &quot;Test&quot; ## ## $element_2 ## [1] 1 3 5 6 10 ## ## $element_3 ## id gender y ## 1 1 m 1 ## 2 2 f 2 ## 3 3 m 3 ## 4 4 f 4 ## 5 5 m 5 ## 6 6 f 6 Exercises Considering the objects created in previous chapters, perform the following exercises (solutions): Create the list experiment_1 containing: DataFrame data_wide matrix A vector x variable info = \"First data collection\" Create the list experiment_2 containing: DataFrame data_long matrix C vector y variable info = \"Second data collection\" 11.2 Selecting Elements As mentioned earlier, each element of a list has its position index, i.e., a progressive numeric value just like the elements of a vector. However, there is an important difference in the selection method based on the type of object you want to retrieve. While with vectors we used single square brackets my_vector[i] to access the element at position \\(i\\), with lists we have two alternatives: my_list[i] - using single square brackets [i], we get a list containing the element at position \\(i\\). However, this does not allow us to directly access its values. my_list[[i]] - using double square brackets [[i]], we extract the element at position \\(i\\) from the list and obtain the object itself, allowing us to directly access its values. Let’s see the difference in the following example: my_list ## $element_1 ## [1] &quot;Test&quot; ## ## $element_2 ## [1] 1 3 5 6 10 ## ## $element_3 ## id gender y ## 1 1 m 1 ## 2 2 f 2 ## 3 3 m 3 ## 4 4 f 4 ## 5 5 m 5 ## 6 6 f 6 # Indexing with [ ] my_list[2] ## $element_2 ## [1] 1 3 5 6 10 class(my_list[2]) # a list ## [1] &quot;list&quot; # Indexing with [[]] my_list[[2]] ## [1] 1 3 5 6 10 class(my_list[[2]]) # a vector ## [1] &quot;numeric&quot; This difference in the result obtained by using single square brackets [ ] or double square brackets [[ ]] is very important because it affects subsequent operations we might perform. Remember that in the first case [ ], we get a list with only the selected elements, while in the second case [[ ]], we directly access the selected object. This distinction becomes clear when applying a generic function to the same element indexed differently or using the str() function to understand the structure. We will see that only by directly accessing the element can we perform normal operations, while with single brackets, the obtained object is a list with a single element. # Apply mean to the vector `element_2` indexed with 1 or 2 brackets mean(my_list[2]) ## Warning in mean.default(my_list[2]): argument is not numeric or logical: ## returning NA ## [1] NA mean(my_list[[2]]) ## [1] 5 # Check structure str(my_list[2]) ## List of 1 ## $ element_2: num [1:5] 1 3 5 6 10 str(my_list[[2]]) ## num [1:5] 1 3 5 6 10 The different type of selection obtained by using single or double square brackets is defined as follows: single square brackets [ ] - returns an object of the same class (i.e., type) as the original object double square brackets [[ ]] - extracts an element from the original object, returning an object not necessarily of the same class (i.e., type) We can use double square brackets even with vectors and data frames, but in these cases, the result does not differ from the normal selection procedure. # Vectors my_vector[2] ## [1] 3 my_vector[[2]] ## [1] 3 # Data frame my_data[, 2] ## [1] &quot;m&quot; &quot;f&quot; &quot;m&quot; &quot;f&quot; &quot;m&quot; &quot;f&quot; my_data[[2]] # selection is only possible on columns ## [1] &quot;m&quot; &quot;f&quot; &quot;m&quot; &quot;f&quot; &quot;m&quot; &quot;f&quot; Finally, note that single square brackets [ ] allow you to select multiple elements simultaneously, while double square brackets [[ ]] allow you to extract only one element at a time. my_list[c(1,2)] ## $element_1 ## [1] &quot;Test&quot; ## ## $element_2 ## [1] 1 3 5 6 10 my_list[[c(1,2)]] ## Error in my_list[[c(1, 2)]]: subscript out of bounds Selection using $ As an alternative to using double square brackets [[ ]], you can, similar to data frames, access the elements of a list using the $ operator and specifying their name: my_list$element_name - the $ operator allows us to directly access the desired object. Let’s see some examples using the list my_list created earlier. # Select &quot;element_1&quot; my_list$element_1 ## [1] &quot;Test&quot; # Select &quot;element_3&quot; my_list$element_3 ## id gender y ## 1 1 m 1 ## 2 2 f 2 ## 3 3 m 3 ## 4 4 f 4 ## 5 5 m 5 ## 6 6 f 6 Note that the element names can also be used with square brackets. ## $element_1 ## [1] &quot;Test&quot; ## ## $element_2 ## [1] 1 3 5 6 10 Using Elements and Subsequent Selections Once we have extracted an element from a list, we can use the object in any way we want. We can either assign the element to a new object for future use or execute functions or other generic operations directly on the selection command. # Mean of the values of &quot;element_2&quot; # Assign the object my_values = my_list$element_2 mean(my_values) ## [1] 5 # Calculate directly mean(my_list$element_2) ## [1] 5 Clearly, the operations we can perform, such as further selections, depend on the specific type and structure of the selected object. # ---- Select the first value of &quot;element_2&quot; ---- my_list$element_2 ## [1] 1 3 5 6 10 my_list$element_2[1] ## [1] 1 my_list[[2]][1] # equivalent to the previous ## [1] 1 # ---- Select the &quot;gender&quot; column from &quot;element_3&quot; ---- my_list$element_3$gender ## [1] &quot;m&quot; &quot;f&quot; &quot;m&quot; &quot;f&quot; &quot;m&quot; &quot;f&quot; # Other equivalent methods my_list[[3]]$gender ## [1] &quot;m&quot; &quot;f&quot; &quot;m&quot; &quot;f&quot; &quot;m&quot; &quot;f&quot; my_list[[3]][, 2] ## [1] &quot;m&quot; &quot;f&quot; &quot;m&quot; &quot;f&quot; &quot;m&quot; &quot;f&quot; my_list[[3]][, &quot;gender&quot;] ## [1] &quot;m&quot; &quot;f&quot; &quot;m&quot; &quot;f&quot; &quot;m&quot; &quot;f&quot; 11.2.1 Advanced Selection Uses Now let’s see some advanced uses of element selection from a data frame. Modifying Elements Similar to other objects, we can modify values by selecting the old element from the list and using the = (or &lt;-) operator to assign a new element. Note that in this case, you can use both single square brackets [ ] and double square brackets [[ ]]. my_list ## $element_1 ## [1] &quot;Test&quot; ## ## $element_2 ## [1] 1 3 5 6 10 ## ## $element_3 ## id gender y ## 1 1 m 1 ## 2 2 f 2 ## 3 3 m 3 ## 4 4 f 4 ## 5 5 m 5 ## 6 6 f 6 # Replace the first element my_list[1] = &quot;A new element&quot; # Replace the second element my_list[[2]] = &quot;Another new element&quot; my_list ## $element_1 ## [1] &quot;A new element&quot; ## ## $element_2 ## [1] &quot;Another new element&quot; ## ## $element_3 ## id gender y ## 1 1 m 1 ## 2 2 f 2 ## 3 3 m 3 ## 4 4 f 4 ## 5 5 m 5 ## 6 6 f 6 Deleting Elements Similar to other objects, to delete elements from a list, you need to specify the position indices of the elements you intend to delete within square brackets, preceded by the - (minus) operator. In this case, the use of single square brackets [ ] is required. # Deleting the second element my_list[-2] ## $element_1 ## [1] &quot;A new element&quot; ## ## $element_3 ## id gender y ## 1 1 m 1 ## 2 2 f 2 ## 3 3 m 3 ## 4 4 f 4 ## 5 5 m 5 ## 6 6 f 6 Remember that deletion is still a selection operation. Therefore, you need to save the resulting list if you want to keep the changes. Exercises Complete the following exercises (solutions) Using numeric indices, select the data for subjects subj_1 and subj_4 regarding the variables age, gender, and group from the data_wide dataframe contained in the list experiment_1. Perform the same selection as the previous exercise, but this time use the name of the object to select the DataFrame from the list. In the list experiment_2, select the objects data_long, y, and info. Change the names of the objects contained in the list experiment_2 to \"experiment_data\", \"VCV_matrix\", \"Id_codes\", and \"notes\", respectively. 11.3 Functions and Operations Let’s now look at some frequently used functions and common operations performed with lists (see Table 11.1). Table 11.1: Table 11.2: Functions and operations with lists Function Description length(nome_df) Number of elements in the list names(nome_df) Names of the list elements nome_list$nome_obj &amp;lt;- oggetto Add a new element to the list c(nome_df) Merge multiple lists unlist(nome_df) Get a vector of all elements str(nome_df) Structure of the dataframe summary(nome_df) Summary of the dataframe Let’s now describe in detail some particular uses, using the example list my_list defined here. Note that the element names have been deliberately omitted. my_list = list(my_value, my_vector, my_data) 11.3.1 Attributes of a List Like other objects, lists have attributes, which provide useful information about the object itself. Let’s now see how to evaluate the size of a list and the names of its elements. Size To evaluate the size of a list, i.e., the number of elements it contains, we can use the length() function. # Number of elements length(my_list) ## [1] 3 Element Names To access the names of the elements in a list, you can use the names() function. If the names were not specified at the time of creation, the result will be NULL. # Check current names names(my_list) ## NULL To assign names to the elements, you will need to assign a character vector with the names to names(my_list). # Assign names names(my_list) = c(&quot;Variable&quot;, &quot;Vector&quot;, &quot;Dataframe&quot;) my_list ## $Variable ## [1] &quot;Test&quot; ## ## $Vector ## [1] 1 3 5 6 10 ## ## $Dataframe ## id gender y ## 1 1 m 1 ## 2 2 f 2 ## 3 3 m 3 ## 4 4 f 4 ## 5 5 m 5 ## 6 6 f 6 11.3.2 Merging Lists To add elements to a list, you can either create a new element using the $ operator, similar to data frames, or combine multiple lists using the c() function. my_list$name = new_obj By writing my_list$name = new_obj you can add a new element to the list, specifying the name and assigning the object new_obj to it. # Add a new element my_list$new_obj = &quot;A new element&quot; my_list ## $Variable ## [1] &quot;Test&quot; ## ## $Vector ## [1] 1 3 5 6 10 ## ## $Dataframe ## id gender y ## 1 1 m 1 ## 2 2 f 2 ## 3 3 m 3 ## 4 4 f 4 ## 5 5 m 5 ## 6 6 f 6 ## ## $new_obj ## [1] &quot;A new element&quot; c() With the c() function, you can combine multiple lists. Note that any new objects you want to include must actually be a list, or you might not get the desired result: # ERROR: combining a list with a vector new_vector = 1:3 c(my_list, new_vector) ## $Variable ## [1] &quot;Test&quot; ## ## $Vector ## [1] 1 3 5 6 10 ## ## $Dataframe ## id gender y ## 1 1 m 1 ## 2 2 f 2 ## 3 3 m 3 ## 4 4 f 4 ## 5 5 m 5 ## 6 6 f 6 ## ## $new_obj ## [1] &quot;A new element&quot; ## ## [[5]] ## [1] 1 ## ## [[6]] ## [1] 2 ## ## [[7]] ## [1] 3 # CORRECT: combining a list with another list c(my_list, list(new_vector = 1:3)) ## $Variable ## [1] &quot;Test&quot; ## ## $Vector ## [1] 1 3 5 6 10 ## ## $Dataframe ## id gender y ## 1 1 m 1 ## 2 2 f 2 ## 3 3 m 3 ## 4 4 f 4 ## 5 5 m 5 ## 6 6 f 6 ## ## $new_obj ## [1] &quot;A new element&quot; ## ## $new_vector ## [1] 1 2 3 In this case, you will need to save the resulting list to preserve the changes. 11.3.3 List Information Finally, let’s look at some common functions used to obtain summary information about the elements of a list: str() allows you to evaluate the structure of the list, providing useful information such as the number of elements and their types. str(my_list) ## List of 4 ## $ Variable : chr &quot;Test&quot; ## $ Vector : num [1:5] 1 3 5 6 10 ## $ Dataframe:&#39;data.frame&#39;: 6 obs. of 3 variables: ## ..$ id : int [1:6] 1 2 3 4 5 6 ## ..$ gender: chr [1:6] &quot;m&quot; &quot;f&quot; &quot;m&quot; &quot;f&quot; ... ## ..$ y : int [1:6] 1 2 3 4 5 6 ## $ new_obj : chr &quot;A new element&quot; summary() provides summary information about the elements, though it is not very useful for lists. summary(my_list) ## Length Class Mode ## Variable 1 -none- character ## Vector 5 -none- numeric ## Dataframe 3 data.frame list ## new_obj 1 -none- character 11.4 Nested Structure Unlike vectors, which extend in length, or data frames/matrices, characterized by rows and columns, the peculiarity of lists (in addition to length, as we have seen) is the concept of depth. A list can contain one or more lists within it, thus creating a very complex nested structure. Despite the more complex structure, the principle of indexing and creation remains the same. Figure 11.2 represents the idea of a nested (or hierarchical) list: Figure 11.2: Conceptual representation of a nested list For a practical example, imagine that \\(n\\) subjects have completed \\(k\\) different experiments, and we want to organize this data structure in R efficiently and orderly. We can imagine an experiments list that contains: Each subject as a list, named s1, s2, …, sn Each element of the subject list is a data frame for the specific experiment, named exp1, exp2, ..., expn # For simplicity, repeat the same experiment and subject # Generic experiment exp_x = data.frame( id = 1:10, gender = rep(c(&quot;m&quot;, &quot;f&quot;), each = 5), y = 1:10 ) # Generic subject sx = list( exp1 = exp_x, exp2 = exp_x, exp3 = exp_x ) # Complete list experiments = list( s1 = sx, s2 = sx, s3 = sx ) str(experiments) ## List of 3 ## $ s1:List of 3 ## ..$ exp1:&#39;data.frame&#39;: 10 obs. of 3 variables: ## .. ..$ id : int [1:10] 1 2 3 4 5 6 7 8 9 10 ## .. ..$ gender: chr [1:10] &quot;m&quot; &quot;m&quot; &quot;m&quot; &quot;m&quot; ... ## .. ..$ y : int [1:10] 1 2 3 4 5 6 7 8 9 10 ## ..$ exp2:&#39;data.frame&#39;: 10 obs. of 3 variables: ## .. ..$ id : int [1:10] 1 2 3 4 5 6 7 8 9 10 ## .. ..$ gender: chr [1:10] &quot;m&quot; &quot;m&quot; &quot;m&quot; &quot;m&quot; ... ## .. ..$ y : int [1:10] 1 2 3 4 5 6 7 8 9 10 ## ..$ exp3:&#39;data.frame&#39;: 10 obs. of 3 variables: ## .. ..$ id : int [1:10] 1 2 3 4 5 6 7 8 9 10 ## .. ..$ gender: chr [1:10] &quot;m&quot; &quot;m&quot; &quot;m&quot; &quot;m&quot; ... ## .. ..$ y : int [1:10] 1 2 3 4 5 6 7 8 9 10 ## $ s2:List of 3 ## ..$ exp1:&#39;data.frame&#39;: 10 obs. of 3 variables: ## .. ..$ id : int [1:10] 1 2 3 4 5 6 7 8 9 10 ## .. ..$ gender: chr [1:10] &quot;m&quot; &quot;m&quot; &quot;m&quot; &quot;m&quot; ... ## .. ..$ y : int [1:10] 1 2 3 4 5 6 7 8 9 10 ## ..$ exp2:&#39;data.frame&#39;: 10 obs. of 3 variables: ## .. ..$ id : int [1:10] 1 2 3 4 5 6 7 8 9 10 ## .. ..$ gender: chr [1:10] &quot;m&quot; &quot;m&quot; &quot;m&quot; &quot;m&quot; ... ## .. ..$ y : int [1:10] 1 2 3 4 5 6 7 8 9 10 ## ..$ exp3:&#39;data.frame&#39;: 10 obs. of 3 variables: ## .. ..$ id : int [1:10] 1 2 3 4 5 6 7 8 9 10 ## .. ..$ gender: chr [1:10] &quot;m&quot; &quot;m&quot; &quot;m&quot; &quot;m&quot; ... ## .. ..$ y : int [1:10] 1 2 3 4 5 6 7 8 9 10 ## $ s3:List of 3 ## ..$ exp1:&#39;data.frame&#39;: 10 obs. of 3 variables: ## .. ..$ id : int [1:10] 1 2 3 4 5 6 7 8 9 10 ## .. ..$ gender: chr [1:10] &quot;m&quot; &quot;m&quot; &quot;m&quot; &quot;m&quot; ... ## .. ..$ y : int [1:10] 1 2 3 4 5 6 7 8 9 10 ## ..$ exp2:&#39;data.frame&#39;: 10 obs. of 3 variables: ## .. ..$ id : int [1:10] 1 2 3 4 5 6 7 8 9 10 ## .. ..$ gender: chr [1:10] &quot;m&quot; &quot;m&quot; &quot;m&quot; &quot;m&quot; ... ## .. ..$ y : int [1:10] 1 2 3 4 5 6 7 8 9 10 ## ..$ exp3:&#39;data.frame&#39;: 10 obs. of 3 variables: ## .. ..$ id : int [1:10] 1 2 3 4 5 6 7 8 9 10 ## .. ..$ gender: chr [1:10] &quot;m&quot; &quot;m&quot; &quot;m&quot; &quot;m&quot; ... ## .. ..$ y : int [1:10] 1 2 3 4 5 6 7 8 9 10 Now the structure is much more complex, but if you have a clear understanding of Figure 11.2 and the indexing of previous lists, accessing elements of the experiments list is simple and intuitive. If we want to access the dataset for subject 3 related to experiment 2: # Using numeric indices experiments[[3]][[2]] # element 3 (a list) and then element 2 ## id gender y ## 1 1 m 1 ## 2 2 m 2 ## 3 3 m 3 ## 4 4 m 4 ## 5 5 m 5 ## 6 6 f 6 ## 7 7 f 7 ## 8 8 f 8 ## 9 9 f 9 ## 10 10 f 10 # Using names (much more intuitive) experiments$s3$exp2 ## id gender y ## 1 1 m 1 ## 2 2 m 2 ## 3 3 m 3 ## 4 4 m 4 ## 5 5 m 5 ## 6 6 f 6 ## 7 7 f 7 ## 8 8 f 8 ## 9 9 f 9 ## 10 10 f 10 If the advantage of a data frame over a matrix is clear, what is the real utility of lists, which are “simply” containers? The main advantages that make lists extremely powerful objects are: Organize complex data structures: As seen in the previous example, sets of nested objects can be organized into a single object without cluttering the workspace with dozens of individual objects. Perform complex operations on multiple objects simultaneously: Imagine having a list of data frames that are structurally similar but contain different data. If you want to apply a function to each data frame, you can organize the data into a list and use functions from the apply family (this is for more advanced users). Finally, due to their flexibility, lists are often used by various packages to return the results of statistical analyses. Knowing how to access the various elements of a list is therefore essential to obtaining specific information and results. "],["third-section.html", "Section 3 - Algorithms", " Section 3 - Algorithms In this section, the main types of objects used in R will be introduced, specifically the primary structures in which data can be organized: Vectors, Matrices, Data Frames, and Lists. For each of them, we will describe their characteristics and see how to create, modify, and manipulate them according to specific needs. The chapters are organized as follows: Chapter 12 - Functions. We will learn how to create custom functions in R to perform specific tasks. Chapter 13 - Conditional Programming. We will learn how to manage the execution of an algorithm through the use of if and else operators. Chapter 14 - Iterative Programming. We will introduce the use of for and while operators for executing loops. "],["functions.html", "Chapter12 Definition of Functions 12.1 Creating a Function 12.2 Working with Functions 12.3 Function Environment 12.4 Best Practices 12.5 Importing a Function", " Chapter12 Definition of Functions In Chapter 4.2, we introduced the concept of functions and saw how they are used to manipulate objects in R and perform numerous tasks. In Chapter 5.3, we also saw how packages can be used to access new functions, thus greatly extending the possible applications of R. However, in R, it is also possible to define your own functions to perform specific tasks according to your own needs. This is one of the main advantages of using a programming language, i.e., being able to develop custom functions according to your needs and not being limited to predefined ones. In this chapter, we will describe how to create your own functions in R. 12.1 Creating a Function The command used to create a function in R is function() followed by curly brackets { } within which the function body must be specified: function_name = function( ){ &lt;function-body&gt; } Note that it is necessary to assign the function to an object, for example my_function, which will become the name of our function. To execute the function, simply, as with any other function, specify the function name followed by parentheses, in our case my_function(). Let’s look at some examples of simple functions: # Define the function my_greetings = function(){ print(&quot;Hello World!&quot;) } my_greetings() ## [1] &quot;Hello World!&quot; # Define another function my_sum = function(){ x = 7 y = 3 x + y } my_sum() ## [1] 10 When we call our function, R will execute the function body and return the result of the last command executed. However, the functions in the previous example prove to be of little use since they always perform the same operations without allowing us to specify the function inputs. Furthermore, even though they are very simple functions, it might not be clear what output is actually returned by the function. :::{design title=“Function Names” data-latex=“[Function Names]”} When defining the name of a function, it’s useful to follow the same guidelines regarding object names (see Chapter 4.1.2). In this case, to ensure the name is self-descriptive, it’s common to use verbs that summarize the action performed by the function. ::: 12.1.1 Defining Inputs and Outputs Remember that, in general, functions receive objects as inputs, perform specific actions, and return new objects as outputs. Input and output are therefore two fundamental aspects of every function that require special attention. Input - We have also seen that in R, inputs are specified through the arguments of a function (see Chapter 4.2.1). To define the arguments of a function, these must be indicated inside the parentheses when creating the function. Output - To specify the output of a function, the return() function is used, indicating between the parentheses the name of the object you wish to return as the result of the function. The definition of a function with all its elements will follow the following pattern: function_name = function(argument_1, argument_2, ...){ &lt;function-body&gt; return(&lt;output-name&gt;) } Now, we can rewrite the previous functions, allowing the inputs to be customized and highlighting what the returned output is. # Redefine my_greetings() my_greetings = function(name){ greetings = paste0(&quot;Hello &quot;, name, &quot;!&quot;) return(greetings) } my_greetings(name = &quot;Psicostat&quot;) ## [1] &quot;Hello Psicostat!&quot; # Redefine my_sum() my_sum = function(x, y){ result = x + y return(result) } my_sum(x = 8, y = 6) ## [1] 14 If necessary, you can make the function itself ask the user to input specific information through the readline() function. Using the readline() function, a message set in the prompt argument will appear in the console (remember to leave a space at the end). The user will be prompted to type an alphanumeric sequence and then press enter. The values entered by the user will be saved as a character variable in the object we specify and can be used later in the function. happy_birthday = function(){ name = readline(prompt = &quot;Enter your name: &quot;) message = paste0(&quot;Happy Birthday &quot;, name, &quot;!&quot;) return(message) } happy_birthday() Note that this function can only be used in interactive R sessions since direct user input is required. Default Arguments We have seen how to add arguments that must be defined by the user when using the function. If the user does not specify one or more arguments, R will return an error message indicating that there are unspecified arguments without default values. my_sum(x = 5) ## Error in my_sum(x = 5): argument &quot;y&quot; is missing, with no default To assign default values to a function’s arguments, simply specify them when creating the function within the parentheses as argument_name = &lt;default-value&gt;. If not otherwise specified, the arguments will take their default values. However, users are free to specify the function’s arguments according to their needs. For example, let’s set a default value for y = 10 in the my_sum() function. my_sum = function(x, y = 10){ result = x + y return(result) } # Use the default value of y my_sum(x = 5) ## [1] 15 # Specify the value of y my_sum(x = 5, y = 8) ## [1] 13 This practice is widely used to specify particular behaviors of functions. Generally, functions are defined with a default behavior, but certain arguments can be specified for particular needs only when necessary. To enforce the selection of an argument from a limited set of values, a vector of possible values can be specified in the argument definition. The selection must then be validated using the match.arg() function, as shown in the following example: # Redefine my_greetings() my_greetings = function(name, type = c(&quot;Hello&quot;, &quot;Goodbye&quot;)){ type = match.arg(type) greetings = paste0(type,&quot; &quot;, name, &quot;!&quot;) return(greetings) } # Choose type my_greetings(name = &quot;Psicostat&quot;, type = &quot;Goodbye&quot;) ## [1] &quot;Goodbye Psicostat!&quot; # Default value my_greetings(name = &quot;Psicostat&quot;) ## [1] &quot;Hello Psicostat!&quot; # Invalid value my_greetings(name = &quot;Psicostat&quot;, type = &quot;Guten Tag&quot;) ## Error in match.arg(type): &#39;arg&#39; should be one of &quot;Hello&quot;, &quot;Goodbye&quot; The match.arg() function allows comparing the specified value against those indicated in the argument definition, returning an error if there is no match. Note how, if unspecified, the default value is the first one indicated in the definition. Exercises Complete the following exercises: Define a function that converts temperature from Celsius to Fahrenheit: \\[ Fahrenheit = Celsius *1.8 + 32 \\] Define a function that sends Christmas and Easter greetings to a person. Define a function that, given a vector of numeric values, calculates the number of elements and their average. Define an interactive function that calculates the product of two values. The inputs must be obtained using the readline() function. Define a function that calculates the monthly salary based on the hours worked in the month and the hourly wage. 12.2 Working with Functions Functions are undoubtedly the most useful and advanced aspect of the R language and programming languages in general. The packages developed in R are nothing more than a collection of functions that work together for a specific purpose. Besides the function’s purpose, it is important to understand how to handle errors and unexpected events. If the function accepts arguments, the end-user or even ourselves can mistakenly use it in the wrong way. Therefore, it is crucial to understand how to read errors but, more importantly, how to create useful error or warning messages for using the function. Let’s take the sum function +, for example. Even though it might not seem like it, the + operator is actually a function. We have already seen above how we could write a my_sum() function that does the same as +: my_sum = function(x, y){ res = x + y return(res) } my_sum(1, 5) ## [1] 6 1 + 5 ## [1] 6 We have defined a (rather simple) function to calculate the sum of two numbers. What happens if we try to add a number to a string? Clearly, this is an operation that makes no sense, and we expect some kind of error: my_sum(&quot;any_string&quot;, 5) ## Error in x + y: non-numeric argument to binary operator In this case, we see an Error... message with the useful information that one of the arguments used is non-numeric. It is a simple, targeted message and, most importantly, it does not provide a result because a fundamental condition (summing applies only to numbers) is not met. The + function already includes this check, but if we wanted to implement a check and provide a message, we have several options: stop(&lt;message&gt;, .call = TRUE): If placed inside a function, it halts execution and provides the specified message as an Error. stopifnot(expr1, expr2, ...): If placed inside a function, it halts execution if at least one of a series of conditions is not TRUE. warning(): Provides a message to the user without stopping execution, offering information about a potential issue stemming from the input or a side effect of the function. message(): Provides a simple message without altering the function’s execution, useful for informing about operations performed. Returning to the sum example, imagine we want to write a function that sums only positive numbers. In other words, we want the x and y values input to the function to be positive in order for the function to execute. We can then include a conditional check and use the stop() function if the condition is not met: my_positive_sum = function(x, y){ if(x &lt; 0 | y &lt; 0){ stop(&quot;The arguments must be positive numbers!&quot;) } res = x + y return(res) } my_positive_sum(10, 5) ## [1] 15 my_positive_sum(10, -5) ## Error in my_positive_sum(10, -5): The arguments must be positive numbers! A faster way to manage execution halts is by using stopifnot(). However, the logic is slightly different from using if + stop(). In the previous example, the logic is: “if x or y is less than 0, stop.” With stopifnot(), we use reverse logic, meaning we specify what we want to be TRUE and halt the execution if it is FALSE. In our case, we use stopifnot(x &gt; 0, y &gt; 0), which means to stop if x or y is NOT greater than 0. Unlike stop(), this does not provide a customized message but returns the first condition that is not met: my_positive_sum = function(x, y){ stopifnot(x &gt; 0, y &gt; 0) res = x + y return(res) } my_positive_sum(10, -5) ## Error in my_positive_sum(10, -5): y &gt; 0 is not TRUE Similarly, let’s imagine (with a bit of imagination) that our function is not reliable for numbers less than 10, meaning it might occasionally produce incorrect results. In this case, we don’t want to halt execution but provide a warning message: my_positive_sum = function(x, y){ # Error if(x &lt; 0 | y &lt; 0){ stop(&quot;The arguments must be positive numbers!&quot;) } # Warning if(x &lt; 10 | y &lt; 10){ warning(&quot;For some strange reason, the function doesn&#39;t handle numbers below 10 very well, be careful! :)&quot;) } res = x + y return(res) } my_positive_sum(15, 4) ## Warning in my_positive_sum(15, 4): For some strange reason, the function ## doesn&#39;t handle numbers below 10 very well, be careful! :) ## [1] 19 As you can see, we get the result (which is, of course, correct), but also a warning message that alerts us to this possible (but not critical) issue. Lastly, we can accompany the result with a message under certain conditions, providing additional information using the message() function: my_positive_sum = function(x, y){ # Error if(x &lt; 0 | y &lt; 0){ stop(&quot;The arguments must be positive numbers!&quot;) } # Warning if(x &lt; 10 | y &lt; 10){ warning(&quot;For some strange reason, the function doesn&#39;t handle numbers below 10 very well, be careful! :)&quot;) } res = x + y message(&quot;Great job! :)&quot;) return(res) } my_positive_sum(12, 10) ## Great job! :) ## [1] 22 One last important aspect concerns what happens when we assign the result of a function in the presence of errors, warnings, or messages. In general, except in cases where errors occur (hence using the stop() function), the output remains the same, and the message is simply printed to the console: res1 = my_positive_sum(10,5) ## Warning in my_positive_sum(10, 5): For some strange reason, the function ## doesn&#39;t handle numbers below 10 very well, be careful! :) ## Great job! :) res2 = my_positive_sum(10,23) ## Great job! :) res3 = my_positive_sum(10,-1) ## Error in my_positive_sum(10, -1): The arguments must be positive numbers! res1 ## [1] 15 res2 ## [1] 33 res3 # no output ## Error in eval(expr, envir, enclos): object &#39;res3&#39; not found As you can see, when an error occurs and we stop execution, the function, despite being expected to return an output, does not provide any result because it was interrupted. 12.3 Function Environment The concept of environment in R is quite complex. In simple terms, all the operations we normally perform in the console or in a script happen within what is called the global environment. When we write and execute a function, we are creating a function object (in the global environment), which in turn creates an internal environment to perform the specified operations. Let’s imagine we have this function my_fun() that takes a value x and adds it to a value y, which is not an argument. my_fun = function(x){ return(x + y) } my_fun(10) ## Error in my_fun(10): object &#39;y&#39; not found Clearly, we get an error because the object y was not created. However, if we create the y object inside the function, it will perform the addition correctly, but it will not create the y object in the global environment. my_fun = function(x){ y = 1 return(x + y) } my_fun(10) ## [1] 11 ls() # we only have our function as an object ## [1] &quot;my_fun&quot; &quot;my_greetings&quot; &quot;my_positive_sum&quot; &quot;my_sum&quot; ## [5] &quot;res1&quot; &quot;res2&quot; From this, it’s clear that what happens inside the function is somewhat compartmentalized compared to the global environment. The only way to influence the global environment is to assign the result of the function, thus creating a new object: res = my_fun(10) ls() ## [1] &quot;my_fun&quot; &quot;my_greetings&quot; &quot;my_positive_sum&quot; &quot;my_sum&quot; ## [5] &quot;res&quot; &quot;res1&quot; &quot;res2&quot; Another important point, especially for managing side effects, is the fact that the function does not modify and does not interfere with objects in the global environment that have the same names as objects within the function environment: y = 10 # global environment my_fun = function(x){ y = 1 # function environment return(x + y) # this uses the function&#39;s y } my_fun(1) ## [1] 2 y ## [1] 10 As you can see, we created an object y inside the function. If executed in the same environment, this would have overwritten the previous value. The result is based on the value of y created in the function environment, and the global y was not modified. One final important point concerns the relationship between the function environment and the global environment. We have seen their independence, but this is not absolute. If, inside the function, we use a variable defined only in the global environment, the function will automatically use that value (if not specified internally). This is useful for allowing functions and global variables to work together, but it is always preferable to create an independent function environment and provide arguments for all the necessary objects. y = 10 my_fun = function(x){ return(x + y) # no &quot;y&quot; exists in the local function environment, therefore, &quot;y&quot; from global environment is used } my_fun(1) ## [1] 11 The key points to remember when defining and using functions are: Every time a function is executed, the internal environment is recreated, so it’s like starting from scratch. Objects created inside the function take precedence over those in the external environment. If the function uses an object not defined internally, it will automatically look for it in the main environment. Note: For a more in-depth discussion of the “Environments” topic, Chapter 7 from Hadley Wickham’s book Advanced R is an excellent resource. 12.4 Best Practices Writing functions is certainly the most important aspect when writing code. It allows you to automate operations, reduce the amount of code, make your script clearer, and reuse a certain portion of code in other contexts. However, there are some conventions and best practices for writing excellent and versatile functions: When is a function necessary? Choosing the name Simplifying the number of operations and outputs Commenting and documenting 12.4.1 When is a Function Necessary? Hadley Wickam suggests that if we repeat a series of operations more than twice, it might be better to write a function. Let’s imagine we have a series of objects and want to perform the same operation on all of them. For example, we want to center (i.e., subtract the mean from all the values of a numeric vector) a numeric vector: vect1 = runif(10) vect2 = runif(10) vect3 = runif(10) In previous chapters, we saw how to use the apply family and how a function can be applied to a series of objects. But let’s imagine a case where we have a very long script and at various points, we perform a certain operation: # Mean centering vect1 - mean(vect2) ## [1] 0.51218837 0.41647402 0.11910163 0.24295132 -0.18253638 0.45223488 ## [7] 0.07381803 0.29566721 0.49384700 -0.28835925 vect2 - mean(vect2) ## [1] -0.3916928 -0.4311577 0.1530123 0.4480443 0.5336326 -0.3138900 ## [7] -0.2989950 -0.1100138 0.2984014 0.1126588 vect3 - mean(vect3) ## [1] -0.154349261 -0.154366112 0.006064214 0.331023839 0.254135514 ## [6] -0.110346556 -0.320860976 0.279703556 -0.395114329 0.264110111 The operation is performed correctly and is also easy to understand. However, we are always doing the same thing, just changing an input (the very definition of a function), so we can: my_fun = function(x){ return(x - mean(x)) } my_fun(vect1) ## [1] 0.29864969 0.20293534 -0.09443705 0.02941264 -0.39607506 0.23869619 ## [7] -0.13972065 0.08212852 0.28030832 -0.50189793 my_fun(vect2) ## [1] -0.3916928 -0.4311577 0.1530123 0.4480443 0.5336326 -0.3138900 ## [7] -0.2989950 -0.1100138 0.2984014 0.1126588 my_fun(vect3) ## [1] -0.154349261 -0.154366112 0.006064214 0.331023839 0.254135514 ## [6] -0.110346556 -0.320860976 0.279703556 -0.395114329 0.264110111 The code hasn’t changed much in terms of lines or complexity. However, imagine realizing an error or wanting to change or extend the operations on vect1, vect2, and vect3. In the first case, you would have to go line by line through the script and modify the code. In the case of a function, simply changing the operations will apply them every time the function is called. Let’s imagine that we also want to standardize (subtract the mean and divide by the standard deviation) our vectors: my_fun = function(x){ res = (x - mean(x)) / sd(x) return(res) } my_fun(vect1) ## [1] 1.0627344 0.7221383 -0.3360509 0.1046638 -1.4094192 0.8493920 ## [7] -0.4971910 0.2922515 0.9974673 -1.7859862 my_fun(vect2) ## [1] -1.0957646 -1.2061679 0.4280533 1.2534082 1.4928424 -0.8781105 ## [7] -0.8364414 -0.3077646 0.8347810 0.3151641 my_fun(vect3) ## [1] -0.57832076 -0.57838390 0.02272159 1.24029073 0.95220309 -0.41345001 ## [7] -1.20221219 1.04800225 -1.48042703 0.98957623 Of course, the combination of functions and the apply family allows everything to be even more compact and efficient: my_list = list(vect1, vect2, vect3) lapply(my_list, my_fun) ## [[1]] ## [1] 1.0627344 0.7221383 -0.3360509 0.1046638 -1.4094192 0.8493920 ## [7] -0.4971910 0.2922515 0.9974673 -1.7859862 ## ## [[2]] ## [1] -1.0957646 -1.2061679 0.4280533 1.2534082 1.4928424 -0.8781105 ## [7] -0.8364414 -0.3077646 0.8347810 0.3151641 ## ## [[3]] ## [1] -0.57832076 -0.57838390 0.02272159 1.24029073 0.95220309 -0.41345001 ## [7] -1.20221219 1.04800225 -1.48042703 0.98957623 12.4.2 Choosing the Name of a Function This might seem like a marginal topic, but the choice of names, both for variables and especially for functions, is extremely important. It allows you to: Read your code clearly and make it understandable to others; Easily organize a group of functions. When you have multiple functions, using appropriate naming allows you to take advantage of RStudio’s suggestions more effectively. For example, the stringr package, which provides tools for working with strings, uses all functions named as str_, making it easier to find the desired function. It is useful to use verbs to name functions and nouns to name arguments. For example, an appropriate name for our last function might be center_var(), while the name of the new vector could be centered_vect or c_vect. If we find center_var in a script, it is immediately clear what that function does, even without looking at the code inside it. 12.4.3 Simplifying the Number of Operations and Outputs This is a very important yet varied point. There are different programming styles, so there are no fixed rules or practices better than others. We said that a function is a way to abstract, reuse, and simplify a series of operations. Therefore, we can write very complex functions that receive various inputs, perform multiple operations, and return several outputs. However, it’s good practice to write functions that: Reduce the number of internal operations Provide a single (or limited) output Have a limited number of inputs If we have designed a function with too many outputs, it’s too complex, or it has too many inputs, we might consider breaking the function into sub-functions. Let’s take an example with our center_vect(). We can think of various alternatives and extensions of this function. For instance, we might want to create a function that either centers or standardizes the vector. We might also choose to center it using the mean or the median. So, we can think of a macro function trans_vect() that transforms the vector based on the arguments: trans_vect = function(x, what = c(&quot;center_mean&quot;, &quot;center_median&quot;, &quot;standardize&quot;)){ if(match.arg(what) == &quot;center_mean&quot;){ res = x - mean(x) }else if(match.arg(what) == &quot;center_median&quot;){ res = x - median(x) }else if(match.arg(what) == &quot;standardize&quot;){ res = (x - mean(x))/sd(x) } return(res) } vect = runif(10) trans_vect(vect, &quot;center_mean&quot;) ## [1] -0.2606982 -0.3939109 -0.1628534 -0.1202977 0.3350573 -0.4773528 ## [7] 0.3172562 0.1723799 0.3283763 0.2620434 trans_vect(vect, &quot;center_mean&quot;) ## [1] -0.2606982 -0.3939109 -0.1628534 -0.1202977 0.3350573 -0.4773528 ## [7] 0.3172562 0.1723799 0.3283763 0.2620434 trans_vect(vect, &quot;standardize&quot;) ## [1] -0.8193559 -1.2380341 -0.5118367 -0.3780872 1.0530614 -1.5002861 ## [7] 0.9971137 0.5417778 1.0320633 0.8235839 The function is very clear, but it still contains some weaknesses. The user must insert a string to perform the operation. There are multiple if conditions, and the function’s purpose might be too broad. A better solution might be to write 3 simpler, more focused, and easier-to-maintain functions: center_vect_mean = function(x){ return(x - mean(x)) } center_vect_median = function(x){ return(x - median(x)) } standardize_vect = function(x){ return((x - mean(x)) / sd(x)) } vect = runif(10) center_vect_mean(vect) ## [1] -0.17848554 0.24728658 0.16412816 -0.39382561 -0.23842770 0.17181115 ## [7] 0.33638602 -0.02496213 0.40080552 -0.48471645 center_vect_median(vect) ## [1] -0.24806856 0.17770356 0.09454514 -0.46340862 -0.30801072 0.10222813 ## [7] 0.26680300 -0.09454514 0.33122251 -0.55429947 standardize_vect(vect) ## [1] -0.57381094 0.79499854 0.52765357 -1.26610504 -0.76651824 0.55235351 ## [7] 1.08144322 -0.08025042 1.28854467 -1.55830887 This way, the code is much more readable and clear, both inside the functions and when the functions are used. Another alternative would be to group the “centering” functions, specifying whether to use the mean or the median, and separate the standardization. 12.4.4 Commenting and Documenting Documentation is perhaps the most important part of writing code. We can classify it into formal and informal documentation, depending on the purpose. Formal documentation is the one we find when using help(function) or ?function. It is standardized and necessary when creating functions in a package that other users need to use. Informal documentation is what we put in our scripts and inside functions as # comment. Both are very important and allow us to describe the general purpose of the function, the individual arguments, and the steps taken. 12.5 Importing a Function We have already seen that the library() command loads a certain package, making the contained functions available for use. Without the need to create a package, we can still organize our functions effectively. We have two options: Write the functions in the same script where they are used. Write a separate script and import all the functions it contains. In this case, it is mainly a matter of style and convenience. Generally: If we have many functions, it’s better to write them in one or more separate files and then import them at the beginning of the main script. If we have few functions, we can keep them in the main script, perhaps in a dedicated section at the start. In the second case, it’s enough to write the function, and it will be saved as an object in the main environment. As for the first scenario, you can use the source(\"path/script.R\") function. The source() function takes the path to an R script, which will then be executed in the background. So, if your directory is organized like this: - working directory/ |-- main_script.R |-- functions/ |-- my_functions.R Where the my_functions.R script is a script where all the functions are declared: fun1 = function(x){ # do } fun2 = function(x){ # do } fun3 = function(x){ # do } ... By writing at the beginning of your main script source(\"functions/my_functions.R\"), all the functions will be loaded into the working environment. "],["conditionals.html", "Chapter13 Conditional Programming 13.1 Conditional Structures 13.2 Other Conditional Operators", " Chapter13 Conditional Programming One of the main constructs of programming is conditional expressions. The simple idea behind this is to perform certain operations or execute operations in a particular way depending on certain conditions. Conditions are just expressions that always return a boolean value, that is, either TRUE or FALSE. The classic example is the umbrella scenario: imagine you’re writing code for a video game and you’ve written a function to make your character take and open the umbrella. Clearly, to make everything believable, you should execute this operation only when needed, that is, when it’s raining. In programming terms, you must first check a certain condition (the rain) and then execute (or not execute) a series of operations accordingly. 13.1 Conditional Structures There are several possibilities in R, but the logic of executing operations only when certain conditions are met is always the same. Figure 13.1 represents the general structure of a conditional control flow. 13.1.1 if knitr::include_graphics(&quot;images/if_chart.png&quot;) Figure 13.1: ‘if’ chart ‘if’ Structure Per scrivere la struttura condizionale della Figura 13.1 si usa la seguente sintassi in R: ... if (&lt;test&gt;) { &lt;code-to-execute&gt; } ... Example Single ‘if’ my_function = function(value){ if(value &gt; 0){ cat(&quot;The value is greater than 0\\n&quot;) } cat(&quot;End of function\\n&quot;) } my_function(5) ## The value is greater than 0 ## End of function my_function(-5) ## End of function Multiple ‘if’ my_function = function(value){ if(value &gt; 0){ cat(&quot;The value is greater than 0\\n&quot;) } if(value &gt; 10){ cat(&quot;The value is greater than 10\\n&quot;) } cat(&quot;End of function\\n&quot;) } my_function(5) ## The value is greater than 0 ## End of function my_function(15) ## The value is greater than 0 ## The value is greater than 10 ## End of function my_function(-5) ## End of function 13.1.2 if…else Using a simple if might not be sufficient in some situations. This is because an if can be seen as a temporary deviation from the main script (clearly illustrated in Figure 13.1) that is taken only if a condition is true; otherwise, the script continues. If you want a more “symmetric” structure, you can execute some operations if the condition is true (if) and others for all other scenarios (else). Figure 13.2 clearly shows this different structure in the flow. knitr::include_graphics(&quot;images/ifelse_chart.png&quot;) Figure 13.2: ‘if…else’ chart ‘if…else’ structure In R, this is implemented as follows: ... if (&lt;test&gt;) { &lt;code-to-execute&gt; } else { &lt;code-to-execute&gt; } ... Example single ‘if…else’ my_function = function(value){ if(value &gt;= 0){ cat(&quot;The value is greater than or equal to 0\\n&quot;) } else { cat(&quot;The value is less than 0\\n&quot;) } cat(&quot;End of function\\n&quot;) } my_function(5) ## The value is greater than or equal to 0 ## End of function my_function(-5) ## The value is less than 0 ## End of function multiple ‘if…else’ my_function = function(value){ if(value &gt; 0){ cat(&quot;The value is greater than 0\\n&quot;) } else if (value &gt; 10){ cat(&quot;The value is greater than 10\\n&quot;) } else { cat(&quot;The value is less than or equal to 0\\n&quot;) } cat(&quot;End of function\\n&quot;) } my_function(5) ## The value is greater than 0 ## End of function my_function(15) ## The value is greater than 0 ## End of function my_function(-5) ## The value is less than or equal to 0 ## End of function It is important to understand the difference between using multiple if and else if compared to using a simple else. If you want to specify a finite set of alternatives, the best and clearest choice is to use else if because, unlike else, it requires you to specify the condition. If, on the other hand, you’re only interested in certain conditions while applying the same operation to everything else, you can conclude your flow with an else. 13.1.3 Nested In addition to chaining a series of if and else if, you can nest one or more if inside another. This allows you to check conditions that depend on the previous check and thus cannot be executed in series. knitr::include_graphics(&quot;images/ifnested.png&quot;) Figure 13.3: Nested ‘if’ Nested ‘if’ structure ... if (&lt;test&gt;) { if(&lt;test&gt;) { &lt;code-to-execute&gt; } else { &lt;code-to-execute&gt; } } ... Example my_function = function(value){ if(value &gt; 0){ if(value &gt; 10) { cat(&quot;The value is greater than 10\\n&quot;) } else { cat(&quot;The value is greater than 0\\n&quot;) } } else { cat(&quot;The value is less than or equal to 0\\n&quot;) } cat(&quot;End of function\\n&quot;) } my_function(5) ## The value is greater than 0 ## End of function my_function(15) ## The value is greater than 10 ## End of function my_function(-5) ## The value is less than or equal to 0 ## End of function Exercises Complete the following exercises: Define a function to assign a grade based on the percentage of correct answers (score) using the following criteria: - score &lt; .55 - insufficient - .55 &lt;= score &lt; .65 - sufficient - .65 &lt;= score &lt; .75 - good - .75 &lt;= score &lt; .85 - very good - .85 &lt;= score - excellent Define a function that determines if a number is even or odd. Define a function that determines if a number is a multiple of 3, 4, or 5. Define a function to calculate the monthly salary considering overtime, which is paid 1.5 times the normal hourly wage. Use the parameters: hours worked in the month, hourly wage, and the work hour threshold beyond which overtime is counted. 13.2 Other Conditional Operators 13.2.1 switch The switch operator is a useful alternative when we want to execute a portion of code conditionally on input without using a series of if. switch structure switch(my_value, case1 = action1, case2 = action2, ... ) In this case, if the input value (my_value) matches one of the cases considered (for example case1), the corresponding code (action1) is executed. There are a few rules to consider when using a switch statement: If the input value is a string, R will look for a match like input == argument. If more than one match is found, the first one is used. There’s no option to insert a default value. If no match is found, NULL is returned. However, by inserting a case without a corresponding value, it will be used instead of NULL. Example my_colors = function(color){ new_color = switch(color, &quot;red&quot; = &quot;red&quot;, &quot;blue&quot; = &quot;blue&quot;, &quot;green&quot; = , &quot;aqua green&quot; = &quot;green&quot;, &quot;Not Found&quot;) # value not found return(new_color) } my_colors(&quot;blue&quot;) ## [1] &quot;blue&quot; my_colors(&quot;green&quot;) ## [1] &quot;green&quot; my_colors(&quot;orange&quot;) ## [1] &quot;Not Found&quot; 13.2.2 ifelse The if, else, and else if statements work only for a single value. In other words, you can’t test the same condition on a series of elements. In the next chapter, we will discuss iterative programming, which allows you to repeat a series of operations. However, using the ifelse() function, you can implement a vectorized version of conditional operations. The structure is as follows: ifelse(test = , yes = , no = ) Where: test is the condition to evaluate, corresponding to what was previously between parentheses in if(test){...}. yes is the code executed if the condition is TRUE. no is the code executed if the condition is FALSE. Example Imagine we have a vector of numbers representing ages, and we want to execute something based on whether the age is greater than or less than 18 years, for example, simply displaying “adult” or “minor”. Using a simple if, we see: age = c(18, 19, 11, 10, 23, 55, 33, 26, 10) if(age &lt; 18){ print(&quot;Minor&quot;) }else{ print(&quot;Adult&quot;) } ## Error in if (age &lt; 18) {: the condition has length &gt; 1 An error is incurred because age is not a single value, and therefore only the first value is used. This demonstrates that if doesn’t work on a list of elements. Instead, using ifelse: age = c(18, 19, 11, 10, 23, 55, 33, 26, 10) ifelse(age &lt; 18, yes = print(&quot;Minor&quot;), no = print(&quot;Adult&quot;)) ## [1] &quot;Minor&quot; ## [1] &quot;Adult&quot; ## [1] &quot;Adult&quot; &quot;Adult&quot; &quot;Minor&quot; &quot;Minor&quot; &quot;Adult&quot; &quot;Adult&quot; &quot;Adult&quot; &quot;Adult&quot; &quot;Minor&quot; In this case, the idea is to execute the previous code for each value in our input vector. This is possible because the &lt; operation is vectorized. "],["loop.html", "Chapter14 Iterative Programming 14.1 Loops 14.2 Nested Loops 14.3 Apply Family 14.4 Replicate", " Chapter14 Iterative Programming The essence of most operations in various programming languages is the concept of iteration. Iteration means repeating a portion of code a certain number of times or until a condition is met. Many of the functions we’ve used so far, such as the sum() or mean() functions, rely on iterative operations. In R, for better or worse, you will rarely use iterations via loops directly, even though they are present in most functions. In fact, many of the functions implemented in R are only available through external packages or must be manually written by implementing iterative structures. 14.1 Loops 14.1.1 For The first type of iterative structure is called a for loop. The idea is to repeat a series of instructions a predetermined number of times. Figure 14.1 represents the concept of a for loop. Similar to the conditional structures discussed in the previous chapter, when we write a loop, we temporarily enter a part of the code, execute the required operations, and then continue with the rest of the code. What is referred to as i in the image is a conventional way of indicating the counting of operations. If we want to repeat an operation 1000 times, i starts at 1 and goes up to 1000. knitr::include_graphics(&quot;images/for_loop.png&quot;) Figure 14.1: Representation of ‘for’ loop ‘For’ Loop Structure In R, the syntax for writing a for loop is as follows: for (i in c(...)) { &lt;code-to-execute&gt; } i is a generic name for the counter variable we introduced earlier. It can be any character, but usually, for a generic loop, single letters like i or j are used, probably due to a similarity with mathematical notation, where these letters are often used to indicate a series of elements. in is the operator that indicates that i varies according to the values specified after it. c(...) is the range of values that i will take for each iteration. We can rephrase the code as: Repeat the operations enclosed in { } a number of times equal to the length of c(...), and in this loop, i will take, one by one, the values contained in c(...). Informally, there are two types of loops: one that uses a generic counter assigned to i and another that directly uses values of interest. Example Loop with directly the values of interest: # numeric # characters for (name in c(&quot;Alessio&quot;, &quot;Beatrice&quot;, &quot;Carlo&quot;)){ print(paste0(&quot;Hello &quot;, name)) } ## [1] &quot;Hello Alessio&quot; ## [1] &quot;Hello Beatrice&quot; ## [1] &quot;Hello Carlo&quot; Loop that uses a generic counter to index the elements: my_vector = c(93, 27, 46, 99) # i in 1:length(my_vector) for (i in seq_along(my_vector)){ print(my_vector[i]) } ## [1] 93 ## [1] 27 ## [1] 46 ## [1] 99 This distinction is very useful and often a source of errors. If you use the vector directly and your counter takes the values of the vector, you “lose” a position index. In the example of the loop with names, if we wanted to know and print the position that Alessio occupies, we would need to modify the approach by using a generic counter as well. We can create it outside the loop and update it manually: i = 1 for (name in c(&quot;Alessio&quot;, &quot;Beatrice&quot;, &quot;Carlo&quot;)){ print(paste0(name, &quot; is number &quot;, i)) i = i + 1 } ## [1] &quot;Alessio is number 1&quot; ## [1] &quot;Beatrice is number 2&quot; ## [1] &quot;Carlo is number 3&quot; In general, the best approach is always to use a loop with indices and not the actual values, so you can access both pieces of information. names = c(&quot;Alessio&quot;, &quot;Beatrice&quot;, &quot;Carlo&quot;) for (i in seq_along(names)){ print(paste0(names[i], &quot; is number &quot;, i)) } ## [1] &quot;Alessio is number 1&quot; ## [1] &quot;Beatrice is number 2&quot; ## [1] &quot;Carlo is number 3&quot; my_vector = c(93, 27, 46, 99) my_NULL = NULL 1:length(my_vector) ## [1] 1 2 3 4 1:length(my_NULL) ## [1] 1 0 seq_along(my_vector) ## [1] 1 2 3 4 seq_along(my_NULL) ## integer(0) seq_len(length(my_vector)) ## [1] 1 2 3 4 seq_len(length(my_NULL)) ## integer(0) Example: The Sum Function As introduced at the beginning of this chapter, many of the available functions in R are derived from iterative structures. If we think about the sum() function, we know that we can calculate the sum of a vector simply with sum(x). To fully understand loops, it’s interesting to think about and implement common functions. If we had to sum n numbers manually, the structure would be as follows: Take the first number \\(x_1\\) and add it to the second \\(x_2\\) You get a new number x_{1+2} Take the third number \\(x_3\\) and add it to x_{1+2} You get \\(x_{1+2+3}\\) Repeat this operation until the last element of \\(x_n\\) As you can see, this is an iterative structure, counting from 1 to the length of \\(x\\), and in each iteration, adding the next number to the sum of the previous ones. In R: my_values = c(2,4,6,8) # Calculate sum of values my_sum = 0 # initialize value for (i in seq_along(my_values)){ my_sum = my_sum + my_values[i] } my_sum ## [1] 20 The structure is the same as our reasoning above. I create a “starting” variable that holds the value 0, and in each iteration, I add the respective indexed element. Example: Creating a Vector Since we use an index that takes a range of values, we can not only access a vector using our index but also progressively create or replace a vector. # Calculate column sum my_matrix = matrix(1:24, nrow = 4, ncol = 6) # Inefficient method (appending values) sum_cols = c() for( i in seq_len(ncol(my_matrix))){ sum_col = sum(my_matrix[, i]) # calculate i-th column sum_cols = c(sum_cols, sum_col) # append the result } sum_cols ## [1] 10 26 42 58 74 90 # Efficient method (updating values) sum_cols = vector(mode = &quot;double&quot;, length = ncol(my_matrix)) for( i in seq_along(sum_cols)){ sum_col = sum(my_matrix[, i]) # calculate i-th column sum_cols[i] = sum_col # update the result } sum_cols ## [1] 10 26 42 58 74 90 14.1.2 While The while loop can be considered a generalization of the for loop. In other words, the for loop is a particular type of while loop. knitr::include_graphics(&quot;images/while_loop.png&quot;) Figure 14.2: Representation of ‘while’ loop While Loop Structure The syntax is more concise than the for loop because we don’t define any counter, placeholder, or a vector of values. The only thing driving a while loop is a logical condition (therefore with TRUE or FALSE values). Again, paraphrasing: Repeat the operations enclosed in { } as long as the &lt;test&gt; condition is TRUE. In other words, at each iteration, the &lt;test&gt; condition is evaluated. If it is true, the operation is executed; otherwise, the loop stops. while (&lt;test&gt;) { &lt;code-to-execute&gt; } Example If we want to perform a countdown: count = 5 while(count &gt;= 0){ print(count) count = count - 1 # update variable Sys.sleep(0.5) # wait half a second before proceeding, just for the suspense :-) } ## [1] 5 ## [1] 4 ## [1] 3 ## [1] 2 ## [1] 1 ## [1] 0 When writing a while loop, it’s important to ensure two things: That the condition is TRUE initially; otherwise, the loop won’t even start. That at some point the condition becomes FALSE (because we have achieved the result or too much time or too many iterations have passed). If the second condition is not met, we end up with what is called an endless loop, like this: count = 5 # Warning: infinite loop while(count &gt;= 0){ print(count) } 14.1.2.1 While and For We previously introduced that for is a particular type of while. Conceptually, we can think of a for loop as a while loop where our counter i increments until it reaches the length of the vector we are iterating over. In other words, we can write a for loop in the following way: names = c(&quot;Alessio&quot;, &quot;Beatrice&quot;, &quot;Carlo&quot;) i = 1 # counter while(i &lt;= length(names)){ # condition print(paste0(names[i], &quot; is number &quot;, i)) i = i + 1 } ## [1] &quot;Alessio is number 1&quot; ## [1] &quot;Beatrice is number 2&quot; ## [1] &quot;Carlo is number 3&quot; 14.1.3 Next and Break Within an iterative structure, we can execute any type of operation, including conditional structures. Sometimes, it may be useful to skip a particular iteration or stop the iterative loop entirely. In R, such operations can be performed with the next and break commands, respectively. next - skips to the next iteration. break - stops the execution of the loop. Example with a for loop: my_vector = 1:6 for (i in seq_along(my_vector)){ if (my_vector[i] == 3) next if (my_vector[i] == 5) break print(my_vector[i]) } ## [1] 1 ## [1] 2 ## [1] 4 with a while loop: count = 7 while(count &gt;= 0){ count = count - 1 if (count == 5) next if (count == 2) break print(count) } ## [1] 6 ## [1] 4 ## [1] 3 14.2 Nested Loops Once you understand the iterative structure, it’s easy to expand its potential by nesting one loop inside another. You can have as many nested loops as necessary, but this increases not only the complexity but also the execution time. To better understand what happens inside a nested loop, it’s helpful to visualize the indices: for(i in 1:3){ # level 1 for(j in 1:3){ # level 2 for(l in 1:3){ # level 3 print(paste(i, j, l)) } } } ## [1] &quot;1 1 1&quot; ## [1] &quot;1 1 2&quot; ## [1] &quot;1 1 3&quot; ## [1] &quot;1 2 1&quot; ## [1] &quot;1 2 2&quot; ## [1] &quot;1 2 3&quot; ## [1] &quot;1 3 1&quot; ## [1] &quot;1 3 2&quot; ## [1] &quot;1 3 3&quot; ## [1] &quot;2 1 1&quot; ## [1] &quot;2 1 2&quot; ## [1] &quot;2 1 3&quot; ## [1] &quot;2 2 1&quot; ## [1] &quot;2 2 2&quot; ## [1] &quot;2 2 3&quot; ## [1] &quot;2 3 1&quot; ## [1] &quot;2 3 2&quot; ## [1] &quot;2 3 3&quot; ## [1] &quot;3 1 1&quot; ## [1] &quot;3 1 2&quot; ## [1] &quot;3 1 3&quot; ## [1] &quot;3 2 1&quot; ## [1] &quot;3 2 2&quot; ## [1] &quot;3 2 3&quot; ## [1] &quot;3 3 1&quot; ## [1] &quot;3 3 2&quot; ## [1] &quot;3 3 3&quot; Looking at the indices, it’s clear that the innermost loop completes first before moving outward. The logic is as follows: In the first iteration, we enter the outermost loop i = 1, then into the inner loop j = 1, and into the innermost loop l = 1. In the second iteration, we are locked in the inner loop, so both i and j remain 1, while l becomes 2. When the innermost loop l finishes, i will still be 1, but j will move to 2, and so on. An important aspect is the use of different indices; indeed, i, j, and l take different values at each iteration, and if we used the same index, we wouldn’t get the desired result. Exercises Write a function that calculates the average of a numeric vector using a for loop. Write a function that, given a numeric vector, returns the maximum and minimum values using a for loop (pay attention to the initialization value). Write a function that, for each iteration, generates \\(n\\) observations from a normal distribution (rnorm() function) with mean \\(mu\\) and standard deviation \\(sigma\\), and saves the mean of each sample. The function parameters will be \\(n\\), \\(mu\\), \\(sigma\\), and \\(iter\\) (number of iterations). 14.3 Apply Family There is a family of extremely powerful and versatile functions in R called *apply. The asterisk suggests a range of variants available in R that, despite their common structure and function, have different objectives: apply: given a dataframe (or matrix), applies the same function to each row or column. tapply: given a vector of values, applies the same function to each group that has been defined. lapply: applies the same function to each element of a list. Returns a list. sapply: applies the same function to each element of a list. If possible, it returns a simplified object (a vector, matrix, or array). vapply: similar to sapply, but requires you to define the type of data to be returned. mapply: the multivariate version. Allows you to apply a function to multiple lists of elements. Before illustrating the various functions, it’s helpful to understand the general structure. Generally, these functions accept a list object (a collection of elements) and a function. The idea is to have a function that takes other functions as arguments and applies the argument-function to each input element. These functions, especially in R, are often preferred over using for loops due to their speed, compactness, and versatility. Hadley Wickam[^talk-map] provides a great example to understand the difference between loop and *apply. Imagine you have a series of vectors and want to apply some functions to each vector; we could set up a simple loop in this way: list_vect = list( vect1 = rnorm(100), vect2 = rnorm(100), vect3 = rnorm(100), vect4 = rnorm(100), vect5 = rnorm(100) ) means = vector(mode = &quot;numeric&quot;, length = length(list_vect)) medians = vector(mode = &quot;numeric&quot;, length = length(list_vect)) st_devs = vector(mode = &quot;numeric&quot;, length = length(list_vect)) for(i in seq_along(list_vect)){ means[i] = mean(list_vect[[i]]) medians[i] = median(list_vect[[i]]) st_devs[i] = sd(list_vect[[i]]) } Although it is perfectly correct, this writing has several problems: It is very redundant. Between calculating the mean, median, and standard deviation, the only thing that changes is the function being applied, while for each, we must pre-allocate a variable, set up indexing based on the iteration to select the list element, and store the result. To improve this, we can wrap the entire structure (pre-allocation, indexing, and storing) into a function and use this function with the list as input and the function to apply. Using the sapply function: means = lapply(list_vect, mean) means ## $vect1 ## [1] -0.1744844 ## ## $vect2 ## [1] -0.001581971 ## ## $vect3 ## [1] 0.003746107 ## ## $vect4 ## [1] -0.1040844 ## ## $vect5 ## [1] 0.2978849 medians = lapply(list_vect, median) medians ## $vect1 ## [1] -0.1336871 ## ## $vect2 ## [1] 0.08244486 ## ## $vect3 ## [1] 0.002455108 ## ## $vect4 ## [1] -0.00886783 ## ## $vect5 ## [1] 0.2095848 st_devs = lapply(list_vect, sd) st_devs ## $vect1 ## [1] 1.028626 ## ## $vect2 ## [1] 1.056527 ## ## $vect3 ## [1] 1.027976 ## ## $vect4 ## [1] 0.9351077 ## ## $vect5 ## [1] 1.04055 As you can see, the code becomes extremely compact, clean, and easy to read. 14.3.1 Which Functions to Apply? Before detailing each *apply function, it’s important to understand what types of functions can be used within this family. In general, any function can be applied, but for convenience, we can distinguish them into: Functions already available in R. Custom functions (created and saved in the main environment). Anonymous functions. In the previous example, we used the mean function simply by writing lapply(list_vec, mean). This is possible because mean requires only one argument. However, if we wanted to apply more complex functions or add arguments, we could use the more general syntax: means = lapply(list_vect, function(x) mean(x)) means ## $vect1 ## [1] -0.1744844 ## ## $vect2 ## [1] -0.001581971 ## ## $vect3 ## [1] 0.003746107 ## ## $vect4 ## [1] -0.1040844 ## ## $vect5 ## [1] 0.2978849 The only difference here is that we defined an anonymous function with the syntax function(x) .... This is interpreted as “for each element of list_vect, treat it as x and apply the mean() function to each element of list_vect.” Anonymous functions allow us to write functions that aren’t saved or available in R and apply them directly to a series of elements. We can also use more complex functions, such as centering each element of list_vect: centered_list = lapply(list_vect, function(x) x - mean(x)) centered_list ## $vect1 ## [1] 0.052024420 0.726941033 0.523133907 0.534116649 1.072538094 ## [6] -1.748085116 0.436228769 1.090050776 0.188256343 1.904447568 ## [11] -0.907720449 -0.098340775 0.356479804 1.683026192 1.778954510 ## [16] -1.666991209 1.797794611 0.305873422 1.655606875 1.687802692 ## [21] -0.767958869 -0.011200606 -0.926640234 1.382599658 -1.450454139 ## [26] 0.279862739 -1.280958942 -0.179531732 0.080784364 1.275153032 ## [31] -1.789340704 -1.273459981 1.193927825 -1.246932674 -0.430047712 ## [36] -1.408989494 -1.111447945 -1.280200478 0.087413286 0.679220848 ## [41] 0.290873113 1.934698137 -0.170632058 2.294484562 0.140106914 ## [46] -0.617669647 1.649999618 -0.551072804 0.486863447 0.866448514 ## [51] -0.325806393 -2.081384947 0.218225732 -0.194333682 -0.785738000 ## [56] 0.278250713 0.601773540 0.004002865 -1.374655893 -1.331115539 ## [61] 0.190527940 -0.010879909 0.566417661 -0.582226517 0.405902013 ## [66] -0.809129005 0.739565224 1.791236297 -0.077479735 -0.881394205 ## [71] -0.173747353 0.131494431 -1.223069551 1.664700735 -0.864902716 ## [76] -0.062460642 -0.824657046 -1.218058185 1.156489655 0.535425340 ## [81] -0.163024811 -0.468903190 -1.992400872 0.807773400 0.029570256 ## [86] -1.065542698 0.708443728 -1.413780392 -0.816480128 0.657745237 ## [91] 0.985102777 -0.119180161 0.121026086 0.909668900 0.189469398 ## [96] 0.052482555 -0.472289289 -0.693373923 -0.334215899 -1.903099951 ## ## $vect2 ## [1] -0.25875450 0.45192195 -0.14129965 -0.48513950 -1.19419119 0.04852296 ## [7] -0.12494971 -2.69913307 -0.56923136 0.59317969 0.48855867 -0.12521792 ## [13] -1.25761789 0.20287395 -1.91532248 1.67432109 0.47237159 1.41569682 ## [19] 0.08588055 -1.80072157 0.75532561 -0.31036112 -1.73097833 -2.13698056 ## [25] 2.36738038 0.48633857 1.09481961 0.30449038 1.01688141 2.45517490 ## [31] -0.24403885 0.54310131 0.19845858 -2.06958035 0.51416551 -0.40417991 ## [37] 0.35777998 -0.32998890 0.08217311 -0.25995052 -0.87586827 0.74289078 ## [43] -2.68138122 -0.94789651 0.44784397 -1.28724749 -0.15622349 0.34939757 ## [49] -0.05804050 1.47831075 -0.65258270 -0.25523286 -1.25245596 0.77262514 ## [55] -0.90976997 -0.69172340 -0.61608640 0.76370516 -1.08557639 -0.39821755 ## [61] 0.82937843 0.35700165 0.16072076 0.95697716 -0.33806032 -0.72579950 ## [67] -1.69622426 1.95572036 2.66831987 2.06496139 0.82036535 -0.07806814 ## [73] -0.48786746 0.84930072 -0.95746280 0.93026931 0.38254698 1.49618576 ## [79] -0.46612240 0.26273926 -0.99102667 -1.06179903 0.27586663 0.94692452 ## [85] 0.72777105 -0.25293070 1.48676214 0.23186813 0.27958462 0.14862272 ## [91] -1.19470741 0.09171824 1.22085175 -0.55991059 0.33846373 -1.53521819 ## [97] -0.23854774 0.51644745 -0.23727325 0.58340054 ## ## $vect3 ## [1] 0.2664491638 -1.3469963272 -0.8526350420 -0.4113540385 -0.6698965617 ## [6] -0.1069834877 -0.9277972315 0.4348533514 -0.0158461161 -0.6496568470 ## [11] 1.3404006827 0.3308553677 -0.0008524137 1.0932070221 1.1595245506 ## [16] 0.0970402348 -0.3954985959 -0.4148154462 -0.9173273893 -0.5441391984 ## [21] 0.1176161927 1.7239915983 -0.0479376631 0.5410962859 1.9136056395 ## [26] -0.2403162233 1.5678772409 0.4771039676 0.0388510442 0.4360775197 ## [31] -1.8843109374 -1.7278160519 1.8794222142 -0.0350334621 0.9952978517 ## [36] 0.2965731726 -0.0089397169 -0.2440504016 -1.7747293817 -0.1599453739 ## [41] 1.9116204426 1.1063735070 -1.9894549474 0.8106197600 1.0945052782 ## [46] -1.4444401450 1.2114915468 -0.7866311249 -2.0708321586 0.3306083127 ## [51] 0.2571921978 -0.4380882424 -1.8767536475 -0.8067906332 0.3285759849 ## [56] 0.0083665339 0.8463602573 -1.5346139219 -0.0353043768 1.4238938000 ## [61] -0.9307764997 1.0018625824 -0.0897035610 0.9342787542 -0.5220418242 ## [66] -0.9382625616 1.2278393538 -0.2433379966 0.2694431409 1.4270790033 ## [71] -1.1447635626 0.8922605510 0.0790918016 0.3463267640 -1.2620371186 ## [76] 0.8359400483 -1.2621666167 0.1493675938 -0.4874471285 2.2071080499 ## [81] 0.0770783378 0.7123603570 1.0507096270 0.2724235769 -0.4240092719 ## [86] 2.5187562528 -0.0017295860 -1.5659889251 -1.9915300574 -1.4957999457 ## [91] 0.2514953082 -0.8182432673 0.8301238234 -1.1562445178 -0.1441958015 ## [96] 1.1723315781 0.1831991812 -0.6985203200 -0.4631891217 -0.4787516183 ## ## $vect4 ## [1] 1.31014158 1.09819466 1.64324210 0.39593137 0.61463274 -0.43683054 ## [7] -0.56982943 0.78423560 0.29079922 -1.28144712 -0.95320981 0.47832305 ## [13] -0.89843251 0.06142016 0.09834140 -0.93750994 -0.22114701 -0.50447853 ## [19] 1.62135004 0.40054994 0.50377989 0.85258426 0.01601205 -0.98150469 ## [25] 0.01879710 0.56958632 0.10405552 0.72039850 -0.54796577 0.55132606 ## [31] -0.07849753 -0.70235630 -1.70546632 -0.67537030 -1.88424294 1.10131999 ## [37] -0.93803709 0.30884776 0.38639004 0.26406936 -1.48220109 0.64941069 ## [43] -1.26245228 -1.01196361 0.26655677 1.61573387 -0.24499703 -1.86615753 ## [49] -0.74331502 -1.66625739 1.19375590 -1.29834857 1.03931548 0.09209179 ## [55] 0.36417167 1.25497932 1.27163836 -1.08423536 0.32463046 1.23838613 ## [61] 0.61505477 -1.39306979 -1.01347083 -0.65377057 -0.67234873 -0.15951329 ## [67] -1.09475421 -1.24828431 0.44936851 -0.81031734 0.48577901 -0.44783374 ## [73] 0.13878656 -0.42861642 1.05753379 0.80005894 -0.56816795 1.42707901 ## [79] -0.24334500 -0.42674961 0.83810754 0.25860309 0.76271285 -0.83189895 ## [85] -1.83769866 0.13777046 -0.34121388 1.28152635 0.02692627 0.65523055 ## [91] -0.34789338 -1.27102060 0.10899483 1.00604579 -0.82845156 0.66493483 ## [97] 0.41550756 1.49611518 2.54392757 -0.08039012 ## ## $vect5 ## [1] -0.97244116 -0.05975831 0.24720098 -0.74673643 0.67336181 -1.84504878 ## [7] -0.10088763 0.54085362 0.19802171 -0.21846188 -1.35504038 -1.00568442 ## [13] -1.66143029 0.32770743 -0.87494585 1.42240563 1.33871389 -0.49724504 ## [19] 0.23183020 -1.28236562 0.94682403 0.15097940 -0.08996773 -1.87922549 ## [25] 0.56434072 1.01141751 0.59054641 0.90708246 1.81054234 1.52125463 ## [31] 1.59879629 0.65703478 -1.36100263 1.52636999 -0.67568978 1.18846185 ## [37] -0.71371197 -0.62705645 -0.34696123 1.81946720 -0.14410534 0.77391802 ## [43] -1.40734286 -0.22652747 -0.08663243 0.24917797 0.10482833 0.40064474 ## [49] -0.11465530 1.67669566 0.89489601 -1.18726409 -0.69802085 -0.34089280 ## [55] -0.31607492 -1.19132141 -1.34752712 0.06417591 0.57868314 1.93393514 ## [61] 1.29099212 0.28454888 -1.05159708 -0.12011029 -1.39846790 -0.34956404 ## [67] 1.15216589 0.47442520 0.42866114 1.24934339 -0.17264100 -0.18756486 ## [73] 1.52868692 -0.50630793 -0.52108509 -2.27123722 0.10655986 -1.07339635 ## [79] -0.53370249 1.60949570 -0.08346146 -1.11549234 -1.60046934 -0.70496768 ## [85] 2.72371679 -0.15590380 -1.05128938 0.86727635 0.28486870 -1.34945579 ## [91] -0.81570377 -1.37540652 0.69447464 -0.31187353 -2.04954616 0.56538309 ## [97] 0.55236386 1.42950364 1.15527183 -0.17463612 In this case, it’s clear that x is a placeholder for each element of the list_vect. The use of anonymous functions is extremely useful and clear once you understand the notation. However, for more complex functions, it’s often more convenient to save the function in an object and then apply it, as with mean. Using the example of centering a variable: center_vect = function(x){ return(x - mean(x)) } centered_list = lapply(list_vect, center_vect) We can also apply complex functions as anonymous by using curly braces, just as if we were declaring a function: center_vect = function(x){ return(x - mean(x)) } centered_list = lapply(list_vect, function(x){ res = x - mean(x) return(res) }) One last point concerns the parallelism between x in our examples and i in the for loops we discussed earlier. Just like i, x is a simple convention, and you can use any name to define the generic argument. Moreover, it’s useful to think of x in the same role as i: in the previous function, x took on the value of each element in list_vect just as the for loop uses the values of the vector we are iterating over. Sometimes, it can be useful to apply an indexing principle with the *apply family as well: means = lapply(seq_along(list_vect), function(i) mean(list_vect[[i]])) means ## [[1]] ## [1] -0.1744844 ## ## [[2]] ## [1] -0.001581971 ## ## [[3]] ## [1] 0.003746107 ## ## [[4]] ## [1] -0.1040844 ## ## [[5]] ## [1] 0.2978849 In this case, the argument is no longer the list but a vector of numbers from 1 to the length of the list (just like in a for loop). The anonymous function then takes i as its argument (which, as we know, can be any name) and uses i to index and apply the function. This may not be extremely useful here, but with this syntax, we have reproduced the exact logic of the for loop in a very compact way. 14.3.2 apply The apply function is used on matrices and dataframes to apply a function to each dimension (row or column). The structure of the function is as follows: apply(X = , MARGIN = , FUN = , ...) Where: X is the dataframe or matrix. MARGIN is the dimension on which to apply the function: 1 = row, 2 = column. FUN is the function to apply. Examples Simple functions: my_matrix = matrix(1:24, nrow = 4, ncol = 6) # For rows apply(my_matrix, MARGIN = 1, FUN = sum) ## [1] 66 72 78 84 # For columns apply(my_matrix, MARGIN = 2, FUN = sum) ## [1] 10 26 42 58 74 90 Complex functions: # Coefficient of Variation apply(my_matrix, MARGIN = 2, FUN = function(x){ mean = mean(x) sd = sd(x) return(round(sd/mean,2)) } ) ## [1] 0.52 0.20 0.12 0.09 0.07 0.06 14.3.3 tapply tapply is useful when you want to apply a function to an element that is grouped by another variable. The syntax is as follows: tapply(X = , INDEX = , FUN = , ...) Where: X is the primary variable. INDEX is the variable by which X is divided. FUN is the function to apply. Examples my_data = data.frame( y = sample(c(2,4,6,8,10), size = 32, replace = TRUE), gender = factor(rep(c(&quot;F&quot;, &quot;M&quot;), each = 16)), class = factor(rep(c(&quot;3&quot;, &quot;5&quot;), times = 16)) ) head(my_data, n = 4) ## y gender class ## 1 8 F 3 ## 2 10 F 5 ## 3 2 F 3 ## 4 4 F 5 # Mean y by class tapply(my_data$y, INDEX = my_data$class, FUN = mean) ## 3 5 ## 5.875 6.625 # Mean y by class and gender tapply(my_data$y, INDEX = list(my_data$class, my_data$gender), FUN = mean) ## F M ## 3 6.50 5.25 ## 5 5.75 7.50 14.3.4 lapply This is perhaps the most commonly used and general function. It can be applied to any type of data, whether a list of elements or a vector. The key characteristic is that it always returns a list as the result, regardless of the input type. The syntax is as follows: lapply(X = , FUN = , ...) Where: X is the vector or list. FUN is the function to apply. Examples my_list = list( sample_norm = rnorm(10, mean = 0, sd = 1), sample_unif = runif(15, min = 0, max = 1), sample_pois = rpois(20, lambda = 5) ) str(my_list) ## List of 3 ## $ sample_norm: num [1:10] 0.343 1.371 0.26 0.482 0.309 ... ## $ sample_unif: num [1:15] 0.031 0.011 0.882 0.113 0.323 ... ## $ sample_pois: int [1:20] 2 3 7 9 5 3 3 5 2 4 ... # Mean lapply(my_list, FUN = mean) ## $sample_norm ## [1] 0.5029392 ## ## $sample_unif ## [1] 0.3935366 ## ## $sample_pois ## [1] 4.25 14.3.5 sapply sapply has the same functionality as lapply but also has the ability to return a simplified version (if possible) of the output. sapply(X = , FUN = , ... ) Examples # Mean sapply(my_list, FUN = mean) ## sample_norm sample_unif sample_pois ## 0.5029392 0.3935366 4.2500000 To understand the difference, let’s apply both lapply and sapply with the previous examples: sapply(list_vect, mean) ## vect1 vect2 vect3 vect4 vect5 ## -0.174484405 -0.001581971 0.003746107 -0.104084425 0.297884925 lapply(list_vect, mean) ## $vect1 ## [1] -0.1744844 ## ## $vect2 ## [1] -0.001581971 ## ## $vect3 ## [1] 0.003746107 ## ## $vect4 ## [1] -0.1040844 ## ## $vect5 ## [1] 0.2978849 sapply(list_vect, mean, simplify = FALSE) ## $vect1 ## [1] -0.1744844 ## ## $vect2 ## [1] -0.001581971 ## ## $vect3 ## [1] 0.003746107 ## ## $vect4 ## [1] -0.1040844 ## ## $vect5 ## [1] 0.2978849 As you can see, the result of these operations corresponds to one value per element of list_vect. lapply returns a list with the results, while sapply returns a vector. In cases like this, where there are single results for each element, sapply is convenient, while keeping the list structure with lapply might be better in other cases. We can also prevent sapply from simplifying the output by using the argument simplify = FALSE. 14.3.6 vapply vapply(X = , FUN = , FUN.VALUE = ,... ) Examples vapplyis similar to both lapply and sapply. However, it requires the type of output to be specified in advance. For this reason, it’s considered a more robust version of the previous functions because it provides more control over what happens. # Mean vapply(my_list, FUN = mean, FUN.VALUE = numeric(length = 1L)) ## sample_norm sample_unif sample_pois ## 0.5029392 0.3935366 4.2500000 In this case, as before, we define the list on which to apply the function. However, the argument FUN.VALUE = numeric(length = 1L) specifies that each result must be a numeric value of length 1. Since we are applying the mean, we obtain a single value for each iteration, and that value must be numeric. sapply() does not always return the same type of object, while vapply() requires you to specify the output type for each iteration. x1 = list( sample_unif = c(-1, runif(15, min = 0, max = 1)), sample_norm = rnorm(5, mean = 0, sd = 1), sample_pois = rpois(20, lambda = 5) ) x2 = list( sample_gamma = c(-1, rgamma(10, shape = 1)), sample_unif = c(-2, runif(15, min = 0, max = 1)), sample_pois = c(-3, rpois(20, lambda = 5)) ) negative_values = function(x) x[x &lt; 0] sapply(x1, negative_values) ## $sample_unif ## [1] -1 ## ## $sample_norm ## [1] -0.95907200 -0.08395547 ## ## $sample_pois ## integer(0) sapply(x2, negative_values) ## sample_gamma sample_unif sample_pois ## -1 -2 -3 vapply(x1, negative_values, FUN.VALUE = numeric(1)) ## Error in vapply(x1, negative_values, FUN.VALUE = numeric(1)): values must be length 1, ## but FUN(X[[2]]) result is length 2 vapply(x2, negative_values, FUN.VALUE = numeric(1)) ## sample_gamma sample_unif sample_pois ## -1 -2 -3 14.3.7 List of Functions Applied to a List of Objects Advanced users may employ the *apply family to extend the “apply a function to a list of objects” formula by applying different functions in a highly compact way. Functions in R are objects like any others and can be stored in lists: list_funs = list( &quot;mean&quot; = mean, &quot;median&quot; = median, &quot;sd&quot; = sd ) lapply(list_funs, FUN = function(f){ sapply(list_vect, FUN = function(x){ f(x) }) } ) ## $mean ## vect1 vect2 vect3 vect4 vect5 ## -0.174484405 -0.001581971 0.003746107 -0.104084425 0.297884925 ## ## $median ## vect1 vect2 vect3 vect4 vect5 ## -0.133687067 0.082444857 0.002455108 -0.008867830 0.209584846 ## ## $sd ## vect1 vect2 vect3 vect4 vect5 ## 1.0286259 1.0565268 1.0279756 0.9351077 1.0405497 What we did here is create a list of functions and then write two lapply and sapply calls in a nested way. Just like when writing two nested loops, the same function is applied to all elements, and then the next function is applied. The result is a list where each element contains the results of applying each function. While this kind of writing is less common, it is useful to understand the logic and power of this approach. ::: 14.3.8 mapply mapply is the most complex version of the apply functions because it extends the number of lists we want to use to n. The syntax is as follows: mapply(FUN, ...) Where: FUN is the function to apply. ... are the lists of elements to which the function is applied. It’s important that all elements have the same length. Let’s try generating some vectors from a normal distribution using the rnorm() function with different values of sample size, mean, and standard deviation: ns = c(10, 3, 5) means = c(10, 20, 30) sds = c(2, 5, 7) mapply(function(x, y, z) rnorm(x, y, z), # function ns, means, sds) # arguments ## [[1]] ## [1] 6.953099 6.854824 9.080728 11.687548 7.215676 7.706871 11.480102 ## [8] 7.142393 8.784290 13.292173 ## ## [[2]] ## [1] 21.99553 14.81288 18.84860 ## ## [[3]] ## [1] 33.26673 22.67479 26.38153 26.86117 25.80392 The syntax is certainly less clear compared to the previous examples, but the idea is as follows: The anonymous function has not just one argument but n arguments. The arguments are specified in order, so in our example x = ns, y = means, and z = sds. At each iteration, the rnorm function gets different sample sizes, means, and standard deviations as arguments. 14.4 Replicate replicate is a slightly different but extremely useful function. It allows you to repeat a series of operations a specified number of times. replicate(n = , expr = ) Where: n is the number of repetitions. expr is the code to repeat. Examples Simple: sample_info = replicate(n = 1000,{ my_sample = rnorm(n = 20, mean = 0, sd = 1) my_mean = mean(my_sample) return(my_mean) }) str(sample_info) ## num [1:1000] 0.395 -0.057 0.252 0.225 0.286 ... Complex: sample_info = replicate(n = 1000, { my_sample = rnorm(n = 20, mean = 0, sd = 1) my_mean = mean(my_sample) my_sd = sd(my_sample) return(data.frame(mean = my_mean, sd = my_sd)) }, simplify = FALSE) sample_info = do.call(&quot;rbind&quot;, sample_info) str(sample_info) ## &#39;data.frame&#39;: 1000 obs. of 2 variables: ## $ mean: num 0.0966 -0.2776 0.1665 0.166 -0.1766 ... ## $ sd : num 1.093 1.059 1.105 1.109 0.954 ... head(sample_info) ## mean sd ## 1 0.09660155 1.0926324 ## 2 -0.27757342 1.0591981 ## 3 0.16649003 1.1050091 ## 4 0.16595363 1.1089836 ## 5 -0.17656075 0.9537385 ## 6 -0.18156384 0.9634895 It’s important to emphasize that repetition is the foundation of any iterative structure we’ve seen so far. In fact, the same result (in terms of readability, speed, and versatility) can be obtained indistinguishably with a for loop, lapply, or replicate. Reusing the previous example: ## replicate set.seed(0) # set seed for reproducibility sample_info = replicate(n = 1000, expr = { my_sample = rnorm(n = 20, mean = 0, sd = 1) my_mean = mean(my_sample) return(my_mean) } ) str(sample_info) ## num [1:1000] -0.00178 0.11165 -0.1156 -0.15386 0.27293 ... ## *apply set.seed(0) # set seed for reproducibility sample_info = sapply(X = 1:1000, FUN = function(x) { my_sample = rnorm(n = 20, mean = 0, sd = 1) my_mean = mean(my_sample) }) str(sample_info) ## num [1:1000] -0.00178 0.11165 -0.1156 -0.15386 0.27293 ... ## for loop set.seed(0) # set seed for reproducibility sample_info = rep(NA, 1000) # initialize before &#39;for&#39; loop for(i in 1:1000) { my_sample = rnorm(n = 20, mean = 0, sd = 1) sample_info[i] = mean(my_sample) } str(sample_info) ## num [1:1000] -0.00178 0.11165 -0.1156 -0.15386 0.27293 ... "],["fourth-section.html", "Section 4 - Advanced Topics", " Section 4 - Advanced Topics In this section, some advanced topics will be briefly introduced, which are nonetheless very useful for working efficiently with R. Various references will be provided so you can further explore these topics on your own. The chapters are organized as follows: Chapter 15 - Strings. We will look at how to manage and manipulate character type objects in R. "],["strings.html", "Chapter15 Strings 15.1 Comparing Strings 15.2 Constructing Strings 15.3 Indexing Strings 15.4 Manipulating Strings 15.5 Regular Expression (REGEX) 15.6 Further Reading", " Chapter15 Strings We have seen that R, besides handling numbers, is also capable of managing characters. Although mathematical operations are not relevant for this type of data, working with strings is just as complex, if not more so, in programming. Compared to numbers, strings: Can be uppercase or lowercase. For example, the string ciao is conceptually the same as Ciao, but R treats them differently. &quot;ciao&quot; == &quot;Ciao&quot; ## [1] FALSE Can contain special characters like ? \\ $ or belong to different alphabets ऊ α The indexing for numbers and strings works differently. If we have a vector of strings, it is represented in the same way as a numeric vector. However, the string itself ciao can be broken down, manipulated, and indexed by the individual characters that compose it: c, i, a, o: vect_string = c(&quot;how&quot;, &quot;are&quot;, &quot;you&quot;) vect_num = c(1,2,3) length(vect_string) ## [1] 3 length(vect_num) ## [1] 3 vect_string[1] ## [1] &quot;how&quot; vect_num[1] ## [1] 1 # Using the nchar() function setNames(nchar(vect_string), vect_string) ## how are you ## 3 3 3 To create a string in R, we must use single or double quotes \"string\" or 'string'. These two syntaxes are interpreted the same way in R. We can use them both to write a string containing quotes: x = &quot;string with &#39;another string&#39; inside&quot; x x = &quot;string with &quot;another string&quot; inside&quot; # This gives an error because R can&#39;t interpret the double quotes correctly ## Error: &lt;text&gt;:4:19: unexpected symbol ## 3: ## 4: x = &quot;string with &quot;another ## ^ Within strings, we can use special characters like / | \\ $ % &amp;. Some of these are interpreted in a specific way by R. When this happens, we need to add the \\ character, which acts as an escape, telling R to interpret the character literally: x = &quot;hello how are you? \\n I’m all good&quot; cat(x) ## hello how are you? ## I’m all good For this reason, R offers a series of functions and packages that allow efficient manipulation of strings. Here, we will see a brief overview of these functions with some suggestions on how to explore them further. 15.1 Comparing Strings The first aspect is comparing strings. The logical comparison of strings is much stricter than that of numbers. As we saw earlier, strings allow for more freedom, but with the challenge of managing more scenarios. # Comparing two numbers represented differently my_integer = as.integer(10) my_double = as.numeric(10) my_integer == my_double ## [1] TRUE # Comparing strings &quot;ciao&quot; == &quot;Ciao&quot; ## [1] FALSE &quot;female&quot; == &quot;feMale&quot; ## [1] FALSE The concept of space “” is also important because it is considered a character: &quot;ciao &quot; == &quot;ciao&quot; ## [1] FALSE Imagine having a vector where a column represents the gender of participants. If this vector comes from people freely entering text in a field, you could end up with something like this (this is why online forms often use predefined options instead of free text): gender = c(&quot;maLe&quot;, &quot;masChio&quot;, &quot;Male&quot;, &quot;f&quot;, &quot;female&quot;, &quot;f&quot;, &quot;malew&quot;) In this exaggerated example, we understand what f or malew (likely a typo) mean, but working with it in R becomes problematic: # Frequency table table(gender) ## gender ## f female maLe Male malew masChio ## 2 1 1 1 1 1 # Not very useful! 15.2 Constructing Strings Let’s look at some useful functions for working with strings. 15.2.1 tolower() and toupper() These functions are extremely useful because they allow you to force the characters to lowercase or uppercase. tolower(gender) ## [1] &quot;male&quot; &quot;maschio&quot; &quot;male&quot; &quot;f&quot; &quot;female&quot; &quot;f&quot; &quot;malew&quot; toupper(gender) ## [1] &quot;MALE&quot; &quot;MASCHIO&quot; &quot;MALE&quot; &quot;F&quot; &quot;FEMALE&quot; &quot;F&quot; &quot;MALEW&quot; 15.2.2 paste() and paste0() These functions allow you to combine different pieces of information into a string. You can combine different strings or even numbers. As is typical in R, paste() and paste0() are vectorized, making them useful for combining two vectors of information. The difference is that paste() automatically adds a space between the combined strings, while with paste0(), the space must be added explicitly. age = c(10, 20, 35, 15, 18) names = c(&quot;Andrea&quot;, &quot;Francesco&quot;, &quot;Fabio&quot;, &quot;Anna&quot;, &quot;Alice&quot;) paste(names, &quot;is&quot;, age, &quot;years old&quot;) ## [1] &quot;Andrea is 10 years old&quot; &quot;Francesco is 20 years old&quot; ## [3] &quot;Fabio is 35 years old&quot; &quot;Anna is 15 years old&quot; ## [5] &quot;Alice is 18 years old&quot; paste0(names, &quot;is&quot;, age, &quot;years old&quot;) ## [1] &quot;Andreais10years old&quot; &quot;Francescois20years old&quot; &quot;Fabiois35years old&quot; ## [4] &quot;Annais15years old&quot; &quot;Aliceis18years old&quot; paste0(names, &quot; is &quot;, age, &quot; years old&quot;) ## [1] &quot;Andrea is 10 years old&quot; &quot;Francesco is 20 years old&quot; ## [3] &quot;Fabio is 35 years old&quot; &quot;Anna is 15 years old&quot; ## [5] &quot;Alice is 18 years old&quot; In this case, although age is numeric, it is coerced into a string to be combined with the names. 15.2.3 sprinf() sprintf() is similar to paste*() in functionality but allows you to compose strings using placeholders and then provide the content. sprintf(&quot;%s is %d years old&quot;, names, age) ## [1] &quot;Andrea is 10 years old&quot; &quot;Francesco is 20 years old&quot; ## [3] &quot;Fabio is 35 years old&quot; &quot;Anna is 15 years old&quot; ## [5] &quot;Alice is 18 years old&quot; In this case, we compose a string using % followed by a letter representing the type of data to insert. We then provide the information in order. Here, %s (string) is for names, and %d (digits) is for age. Use ?sprintf for an overview of the placeholders available. 15.3 Indexing Strings 15.3.1 nchar() As we saw earlier, a string is made up of a sequence of characters. The nchar() function returns the number of individual characters that make up a string. nchar(&quot;ciao&quot;) ## [1] 4 nchar(&quot;Wow, working with strings is very fun&quot;) ## [1] 37 15.3.2 gregexpr() and regexpr() To find the position of one or more characters within a string, we can use gregexpr(). The syntax is (g)gregexpr(pattern, string): regexpr(&quot;t&quot;, &quot;butterfly&quot;) ## [1] 3 ## attr(,&quot;match.length&quot;) ## [1] 1 ## attr(,&quot;index.type&quot;) ## [1] &quot;chars&quot; ## attr(,&quot;useBytes&quot;) ## [1] TRUE gregexpr(&quot;t&quot;, &quot;butterfly&quot;) ## [[1]] ## [1] 3 4 ## attr(,&quot;match.length&quot;) ## [1] 1 1 ## attr(,&quot;index.type&quot;) ## [1] &quot;chars&quot; ## attr(,&quot;useBytes&quot;) ## [1] TRUE The difference is that regexpr() only returns the first match — in our example, the first t is in the 3rd position — while gregexpr() returns all matches. 15.3.3 substr() and substring() The inverse process — that is, finding the string corresponding to a given index — is the task of substr(string, start, stop) where start and stop are the indices of the portion of the string we want to extract. substring() works the same way, but start and stop are called first and last. substr(&quot;butterfly&quot;, 1, 1) # only the first character ## [1] &quot;b&quot; substr(&quot;butterfly&quot;, 2, 4) # second to fourth character ## [1] &quot;utt&quot; For these tasks, both functions provide exactly the same result. Let’s examine the differences: substring() allows you to provide only the initial index first and the final index defaults to 1000000L. substring() also allows you to provide a vector of start/end indices to segment the string. substring(&quot;butterfly&quot;, 1) # works ## [1] &quot;butterfly&quot; substr(&quot;butterfly&quot;, 1) # error ## Error in substr(&quot;butterfly&quot;, 1): argument &quot;stop&quot; is missing, with no default substring(&quot;butterfly&quot;, 1, 1:5) # multiple end indices ## [1] &quot;b&quot; &quot;bu&quot; &quot;but&quot; &quot;butt&quot; &quot;butte&quot; substring(&quot;butterfly&quot;, 1:5, 1:5) # multiple start and end indices ## [1] &quot;b&quot; &quot;u&quot; &quot;t&quot; &quot;t&quot; &quot;e&quot; substr(&quot;butterfly&quot;, 1, 1:5) # only one (i.e., the first) end index is used ## [1] &quot;b&quot; 15.3.4 startWith() and endsWith() Sometimes we are only interested in the beginning or the end of a string. For example, female and male have a clear initial difference (fe and ma). Even with subsequent typos or other differences, selecting only the beginning or end can be efficient. startsWith() and endsWith() respectively return TRUE or FALSE if a certain string or vector of strings has a given initial or final pattern. startsWith(&quot;female&quot;, prefix = &quot;fe&quot;) ## [1] TRUE endsWith(&quot;female&quot;, suffix = &quot;ale&quot;) ## [1] TRUE These, like the other functions, can be combined with tolower() or toupper() to ignore irrelevant differences. 15.3.5 grep() and grepl() These functions operate on vectors of strings, finding the position or simple presence of specific patterns. grep() returns the position(s) in the vector where a match is found, while grepl() returns TRUE or FALSE depending on the presence of the pattern. The syntax is the same grep*(pattern, vector). gender ## [1] &quot;maLe&quot; &quot;masChio&quot; &quot;Male&quot; &quot;f&quot; &quot;female&quot; &quot;f&quot; &quot;malew&quot; grep(&quot;female&quot;, gender) # index of position ## [1] 5 grepl(&quot;female&quot;, gender) # true or false ## [1] FALSE FALSE FALSE FALSE TRUE FALSE FALSE As we saw with logical indexing of vectors, we can use both grep() and grepl() to select only certain elements: index_grep = grep(&quot;female&quot;, gender) # index of position index_grepl = grepl(&quot;female&quot;, gender) # logical index gender[index_grep] ## [1] &quot;female&quot; gender[index_grepl] ## [1] &quot;female&quot; Note again how all these functions work on a very strict match (in terms of upper/lowercase, etc.) between pattern and target. 15.4 Manipulating Strings Many of the functions we’ve seen also allow replacing a certain pattern within a string or vector of strings. Using substr() or substring() with the assignment operator = (or &lt;-), we can replace certain characters. Importantly, the replacement must have the same number of characters as the selection start:stop, or only the corresponding number of characters will be used: x = &quot;butterfly&quot; substr(x, 1, 1) = &quot;y&quot; x ## [1] &quot;yutterfly&quot; x = &quot;butterfly&quot; substr(x, 1, 1) = &quot;aeiou&quot; x # only the &#39;a&#39; is used ## [1] &quot;autterfly&quot; # substring works exactly the same way x = &quot;butterfly&quot; substring(x, 1, 1) = &quot;z&quot; x ## [1] &quot;zutterfly&quot; They can also be used in a vectorized manner, working on multiple elements: x = c(&quot;dog&quot;, &quot;cat&quot;, &quot;mouse&quot;, &quot;butterfly&quot;) substring(x, 1, 1) = &quot;z&quot; x ## [1] &quot;zog&quot; &quot;zat&quot; &quot;zouse&quot; &quot;zutterfly&quot; 15.4.1 gsub() and sub() Unlike substring(), gsub() and sub() allow you to replace a certain pattern rather than using position indices. The syntax is *sub(pattern, replacement, target): x = c(&quot;dog&quot;, &quot;cat&quot;, &quot;mouse&quot;, &quot;butterfly&quot;) sub(&quot;o&quot;, &quot;z&quot;, x) ## [1] &quot;dzg&quot; &quot;cat&quot; &quot;mzuse&quot; &quot;butterfly&quot; As you can see, for each element of x, the function found the pattern \"o\" and replaced it with \"z\". The main limitation of sub() is that it only replaces the first match found in each string. x = c(&quot;dog&quot;, &quot;cat&quot;, &quot;mouse&quot;, &quot;butterfly&quot;) sub(&quot;t&quot;, &quot;z&quot;, x) ## [1] &quot;dog&quot; &quot;caz&quot; &quot;mouse&quot; &quot;buzterfly&quot; As you can see, only the first \"t\" in the word \"butterfly\" was replaced. gsub(), however, replaces all characters that match the requested pattern: x = c(&quot;dog&quot;, &quot;cat&quot;, &quot;mouse&quot;, &quot;butterfly&quot;) gsub(&quot;t&quot;, &quot;z&quot;, x) ## [1] &quot;dog&quot; &quot;caz&quot; &quot;mouse&quot; &quot;buzzerfly&quot; 15.4.2 strsplit() We’ve already seen that, with substring(), we can, for example, divide a string into several parts. According to the R documentation, the strsplit() function is more suitable and efficient for this task. The syntax is strsplit(target, split) where split is the character used to divide: my_string = &quot;How nice it is to work with strings in R&quot; strsplit(my_string, &quot; &quot;) # splitting by spaces ## [[1]] ## [1] &quot;How&quot; &quot;nice&quot; &quot;it&quot; &quot;is&quot; &quot;to&quot; &quot;work&quot; &quot;with&quot; ## [8] &quot;strings&quot; &quot;in&quot; &quot;R&quot; my_string = &quot;howxnicexitxis&quot; strsplit(my_string, &quot;x&quot;) # splitting by the &quot;x&quot; character ## [[1]] ## [1] &quot;how&quot; &quot;nice&quot; &quot;it&quot; &quot;is&quot; my_string = &quot;ciao&quot; strsplit(my_string, &quot;&quot;) # splitting each character ## [[1]] ## [1] &quot;c&quot; &quot;i&quot; &quot;a&quot; &quot;o&quot; What we get is a vector (within a list, you can use unlist()) that contains the result of the splitting. 15.5 Regular Expression (REGEX) Is everything this simple with strings? Absolutely not! So far, we’ve used simple patterns like single characters or sets of characters, but we may have more complex problems to address, such as: finding the extension of a set of files finding the domain of a website Let’s consider an example: files = c( &quot;file1.txt&quot;, &quot;file2.docx&quot;, &quot;file3.doc&quot;, &quot;file4.sh&quot; ) In this case, if we want to extract all the extensions filename.extension, the tools we’ve seen so far are insufficient: we could extract characters from the end using substr() and counting with nchar(), but extensions don’t have a fixed number of characters we could search for all patterns using grepl(), but there are thousands of different extensions So far, we’ve seen two levels of abstraction: Literal match: string1 == string2 Indexing: position within a st The third level of abstraction is finding common patterns in strings and extracting them, regardless of the individual characters, numbers, or positions. Regular Expressions (REGEX) are a set of characters (called metacharacters) that are interpreted and allow you to find patterns in strings without specifying a specific pattern or position index. The topic is very complex and not specific to R. There are plenty of guides and tutorials available online, which we will list at the end of this chapter. The important thing to know is that most of the functions we’ve seen allow the use of a regex in addition to a specific pattern to solve more complex problems. For example, if we want to extract the extension from a list of files, the reasoning would be: we need to find a . because (almost) all files are composed of filename.extension we need to select all characters from the dot to the end of the string The “translation” in terms of REGEX is \"\\\\.([^.]+)$\", and we can use this as a pattern to extract the information we need. We can use the regmatches(text, match) function, which requires the string to analyze and a match object, which is the result of the regexpr function we’ve already seen: match_regex = regexpr(&quot;\\\\.([^.]+)$&quot;, files) regmatches(files, match_regex) ## [1] &quot;.txt&quot; &quot;.docx&quot; &quot;.doc&quot; &quot;.sh&quot; 15.6 Further Reading Throughout this book, we have aimed to approach R as a programming language by focusing on its basic functions. However, in certain areas, such as strings and REGEX, there are highly recommended external packages that not only simplify tasks but also make the set of functions more organized and consistent. The stringr package is a fantastic resource for learning and for working more efficiently with strings. It contains a series of functions built on top of those we’ve covered, simplifying them and providing uniformity. The last example we described isn’t very readable since it involves using the result of another function and calling the target object twice. In stringr, we have the str_extract() function, which extracts a certain pattern or REGEX: stringr::str_extract(files, &quot;\\\\.([^.]+)$&quot;) ## [1] &quot;.txt&quot; &quot;.docx&quot; &quot;.doc&quot; &quot;.sh&quot; 15.6.1 Useful Resources stringr Chapter 14 di R for Data Science Mastering Regular Expressions Handling Strings With R 15.6.2 Other Useful Functions abbreviate() "],["404.html", "Page not found", " Page not found The page you requested cannot be found (perhaps it was moved or renamed). You may want to try searching to find the page's new location, or use the table of contents to find the page you are looking for. "]]
